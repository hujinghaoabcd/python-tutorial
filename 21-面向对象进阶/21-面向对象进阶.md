# 第21章：面向对象进阶

学习继承、多态和封装，掌握面向对象的高级特性。

## 继承（Inheritance）

### 从生活中理解继承

想象一下手机的发展历史：

**第一代手机**：只能打电话
- 功能：拨号、接听、挂断

**第二代手机（继承第一代）**：在打电话的基础上，增加了发短信
- 继承：拨号、接听、挂断（从第一代继承来的）
- 新增：发短信、收短信

**第三代智能手机（继承第二代）**：在前两代的基础上，增加了上网、拍照
- 继承：打电话、发短信（从前面继承来的）
- 新增：上网、拍照、装App

这就是**继承**的思想！新的东西不需要从零开始，可以在旧的基础上扩展。

**编程中的继承**就是这个道理：
- 子类继承父类的属性和方法
- 子类可以添加自己的新功能
- 子类可以修改（重写）父类的功能

### 为什么需要继承？

**场景：动物园管理系统**

假设你要管理一个动物园，里面有狗、猫、鸟等很多动物。每个动物都有：
- 共同特征：名字、年龄、体重
- 共同行为：吃饭、睡觉
- 独特行为：狗会汪汪叫，猫会喵喵叫，鸟会飞

不使用继承的做法（代码重复）：

```python
# ❌ 不好的做法：每个类都重复写相同的代码
class Dog:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def eat(self):  # 重复代码
        print(f"{self.name}在吃东西")

    def sleep(self):  # 重复代码
        print(f"{self.name}在睡觉")

    def bark(self):  # 狗特有的
        print(f"{self.name}在汪汪叫")

class Cat:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def eat(self):  # 又重复了！
        print(f"{self.name}在吃东西")

    def sleep(self):  # 又重复了！
        print(f"{self.name}在睡觉")

    def meow(self):  # 猫特有的
        print(f"{self.name}在喵喵叫")

class Bird:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def eat(self):  # 还是重复！
        print(f"{self.name}在吃东西")

    def sleep(self):  # 还是重复！
        print(f"{self.name}在睡觉")

    def fly(self):  # 鸟特有的
        print(f"{self.name}在飞")

# 如果有100种动物，你要重复写100次eat()和sleep()！
```

**问题**：
- 代码重复太多（eat和sleep重复了3次）
- 如果要修改eat()的逻辑，需要改3个地方
- 容易出错，维护困难

使用继承的做法（代码复用）：

```python
# ✅ 好的做法：使用继承
class Animal:
    """动物基类 - 定义所有动物的共同特征"""
    def __init__(self, name, age):
        self.name = name
        self.age = age
        print(f"创建了动物：{name}")

    def eat(self):
        """所有动物都会吃"""
        print(f"{self.name}在吃东西")

    def sleep(self):
        """所有动物都会睡觉"""
        print(f"{self.name}在睡觉")

    def get_info(self):
        """获取基本信息"""
        return f"{self.name}，{self.age}岁"

class Dog(Animal):
    """狗类 - 继承Animal"""
    # 继承了：__init__, eat(), sleep(), get_info()
    # 只需要写狗特有的功能！

    def bark(self):
        """狗特有的叫声"""
        print(f"{self.name}说：汪汪汪！")

    def wag_tail(self):
        """狗特有的摇尾巴"""
        print(f"{self.name}开心地摇尾巴")

class Cat(Animal):
    """猫类 - 继承Animal"""
    # 同样继承了Animal的所有功能

    def meow(self):
        """猫特有的叫声"""
        print(f"{self.name}说：喵喵喵！")

    def purr(self):
        """猫特有的打呼噜"""
        print(f"{self.name}满足地打呼噜")

class Bird(Animal):
    """鸟类 - 继承Animal"""

    def __init__(self, name, age, can_fly=True):
        # 调用父类的__init__
        super().__init__(name, age)
        self.can_fly = can_fly  # 鸟类特有的属性

    def chirp(self):
        """鸟特有的叫声"""
        print(f"{self.name}说：叽叽喳喳！")

    def fly(self):
        """鸟特有的飞行"""
        if self.can_fly:
            print(f"{self.name}在天空中飞翔")
        else:
            print(f"{self.name}是不会飞的鸟（如企鹅）")

# 使用示例
print("=== 创建动物 ===")
dog = Dog("旺财", 3)
cat = Cat("咪咪", 2)
bird = Bird("小鸟", 1)
penguin = Bird("企鹅", 5, can_fly=False)

print("\n=== 使用继承的方法 ===")
# 所有动物都能吃和睡（从Animal继承）
dog.eat()      # 旺财在吃东西
cat.eat()      # 咪咪在吃东西
bird.eat()     # 小鸟在吃东西

dog.sleep()    # 旺财在睡觉
cat.sleep()    # 咪咪在睡觉

print("\n=== 使用各自特有的方法 ===")
dog.bark()     # 汪汪汪
dog.wag_tail() # 摇尾巴

cat.meow()     # 喵喵喵
cat.purr()     # 打呼噜

bird.chirp()   # 叽叽喳喳
bird.fly()     # 在天空中飞翔
penguin.fly()  # 企鹅是不会飞的鸟

print("\n=== 获取信息 ===")
print(dog.get_info())  # 旺财，3岁（从Animal继承的方法）
print(cat.get_info())  # 咪咪，2岁
```

**继承的好处**：
1. ✅ **代码复用**：共同的代码只写一次
2. ✅ **易于维护**：修改一处，所有子类都生效
3. ✅ **逻辑清晰**：父类定义共性，子类定义特性
4. ✅ **易于扩展**：新增动物类型很容易

### 继承的基本概念

```python
# 语法格式
class 父类名:
    """父类也叫：基类、超类（Superclass）"""
    pass

class 子类名(父类名):
    """子类也叫：派生类（Subclass）"""
    pass
```

**继承关系**：
- 子类**拥有**父类的所有属性和方法
- 子类是父类的**特殊化**版本
- 父类是子类的**泛化**版本

**形象理解**：
```python
# 形状（父类）
#   ├── 矩形（子类）
#   │     └── 正方形（子子类）
#   ├── 圆形（子类）
#   └── 三角形（子类）

class Shape:
    """形状基类"""
    def __init__(self, color):
        self.color = color

    def show_color(self):
        print(f"颜色：{self.color}")

class Rectangle(Shape):
    """矩形继承形状"""
    def __init__(self, color, width, height):
        super().__init__(color)  # 继承父类属性
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

class Square(Rectangle):
    """正方形继承矩形"""
    def __init__(self, color, side):
        # 正方形是特殊的矩形（长宽相等）
        super().__init__(color, side, side)

# 测试
rect = Rectangle("红色", 10, 5)
rect.show_color()  # 继承自Shape
print(f"面积：{rect.area()}")  # Rectangle自己的方法

square = Square("蓝色", 5)
square.show_color()  # 继承自Shape
print(f"面积：{square.area()}")  # 继承自Rectangle
```

### 继承的术语

| 术语 | 英文 | 说明 | 例子 |
|-----|------|------|------|
| 父类 | Parent Class, Base Class, Superclass | 被继承的类 | Animal |
| 子类 | Child Class, Derived Class, Subclass | 继承的类 | Dog, Cat |
| 单继承 | Single Inheritance | 一个子类只有一个父类 | Dog(Animal) |
| 多重继承 | Multiple Inheritance | 一个子类有多个父类 | Duck(Flyable, Swimmable) |
| 方法重写 | Method Override | 子类重新定义父类的方法 | Dog.speak() 重写 Animal.speak() |
| 方法扩展 | Method Extension | 子类扩展父类的方法 | 调用super()再添加新逻辑 |

继承让子类获得父类的属性和方法，实现代码重用。这是面向对象编程最重要的特性之一！

### 方法重写（Override）

子类可以重写父类的方法。

```python
class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        return "某种声音"

class Dog(Animal):
    def speak(self):
        """重写父类方法"""
        return f"{self.name}说: 汪汪!"

class Cat(Animal):
    def speak(self):
        """重写父类方法"""
        return f"{self.name}说: 喵喵!"

# 使用
dog = Dog("旺财")
cat = Cat("咪咪")

print(dog.speak())  # 旺财说: 汪汪!
print(cat.speak())  # 咪咪说: 喵喵!
```

## super() 函数

`super()` 用于调用父类的方法。

### 调用父类构造方法

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
        print(f"Person.__init__ 被调用")

class Student(Person):
    def __init__(self, name, age, student_id):
        # 调用父类构造方法
        super().__init__(name, age)
        self.student_id = student_id
        print(f"Student.__init__ 被调用")

    def get_info(self):
        return f"{self.name}, {self.age}岁, 学号{self.student_id}"

student = Student("张三", 18, "2024001")
print(student.get_info())
```

### 调用父类普通方法

```python
class Rectangle:
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

class Square(Rectangle):
    def __init__(self, side):
        # 正方形的宽和高相等
        super().__init__(side, side)

    def area(self):
        # 可以调用父类方法
        base_area = super().area()
        print(f"计算正方形面积：{base_area}")
        return base_area

square = Square(5)
print(square.area())  # 25
```

## 多重继承

Python支持多重继承（一个类继承多个父类）。

```python
class Flyable:
    """会飞的"""
    def fly(self):
        print(f"{self.name}在飞")

class Swimmable:
    """会游泳的"""
    def swim(self):
        print(f"{self.name}在游泳")

class Duck(Flyable, Swimmable):
    """鸭子：既会飞又会游泳"""
    def __init__(self, name):
        self.name = name

duck = Duck("唐老鸭")
duck.fly()   # 鸭子在飞
duck.swim()  # 鸭子在游泳
```

### 方法解析顺序（MRO）

```python
class A:
    def method(self):
        print("A.method")

class B(A):
    def method(self):
        print("B.method")

class C(A):
    def method(self):
        print("C.method")

class D(B, C):
    pass

d = D()
d.method()  # B.method

# 查看方法解析顺序
print(D.__mro__)
# (<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>,
#  <class '__main__.A'>, <class 'object'>)
```

## 多态（Polymorphism）

多态意味着不同的类可以有相同的方法名，但实现不同的行为。

### 基本示例

```python
class Shape:
    """形状基类"""
    def area(self):
        pass

    def perimeter(self):
        pass

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

    def perimeter(self):
        return 2 * (self.width + self.height)

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return 3.14159 * self.radius ** 2

    def perimeter(self):
        return 2 * 3.14159 * self.radius

# 多态：同样的接口，不同的实现
shapes = [
    Rectangle(5, 3),
    Circle(4),
    Rectangle(10, 2)
]

for shape in shapes:
    print(f"面积: {shape.area():.2f}, 周长: {shape.perimeter():.2f}")
```

### 鸭子类型（Duck Typing）

Python是动态类型语言，只要对象有相应的方法，就可以调用。

```python
class Duck:
    def quack(self):
        print("嘎嘎嘎")

    def fly(self):
        print("鸭子飞")

class Person:
    def quack(self):
        print("人模仿鸭子叫")

    def fly(self):
        print("人不能飞，但可以坐飞机")

def make_it_quack(thing):
    """只要有quack方法就行"""
    thing.quack()

# 都可以调用
make_it_quack(Duck())    # 嘎嘎嘎
make_it_quack(Person())  # 人模仿鸭子叫
```

## 封装（Encapsulation）

封装是将数据和操作数据的方法绑定在一起，并隐藏内部实现细节。

### 私有属性

```python
class BankAccount:
    def __init__(self, owner, balance=0):
        self.owner = owner
        self.__balance = balance  # 私有属性（双下划线）

    def deposit(self, amount):
        """存款"""
        if amount > 0:
            self.__balance += amount
            return True
        return False

    def withdraw(self, amount):
        """取款"""
        if 0 < amount <= self.__balance:
            self.__balance -= amount
            return True
        return False

    def get_balance(self):
        """获取余额（公开接口）"""
        return self.__balance

account = BankAccount("张三", 1000)

# 不能直接访问私有属性
# print(account.__balance)  # AttributeError

# 通过公开方法访问
print(account.get_balance())  # 1000
account.deposit(500)
print(account.get_balance())  # 1500
```

### 属性装饰器（@property）

```python
class Circle:
    def __init__(self, radius):
        self._radius = radius

    @property
    def radius(self):
        """获取半径"""
        return self._radius

    @radius.setter
    def radius(self, value):
        """设置半径"""
        if value < 0:
            raise ValueError("半径不能为负数")
        self._radius = value

    @property
    def area(self):
        """只读属性"""
        return 3.14159 * self._radius ** 2

    @property
    def diameter(self):
        """直径"""
        return 2 * self._radius

circle = Circle(5)

# 像访问属性一样使用
print(circle.radius)    # 5
print(circle.area)      # 78.53975
print(circle.diameter)  # 10

# 可以设置
circle.radius = 10
print(circle.area)      # 314.159

# 不能设置只读属性
# circle.area = 100  # AttributeError
```

## 抽象基类

使用`abc`模块定义抽象基类。

```python
from abc import ABC, abstractmethod

class Animal(ABC):
    """抽象动物类"""

    def __init__(self, name):
        self.name = name

    @abstractmethod
    def speak(self):
        """抽象方法：子类必须实现"""
        pass

    @abstractmethod
    def move(self):
        """抽象方法"""
        pass

class Dog(Animal):
    def speak(self):
        return f"{self.name}说: 汪汪!"

    def move(self):
        return f"{self.name}在跑"

class Bird(Animal):
    def speak(self):
        return f"{self.name}说: 叽叽喳喳!"

    def move(self):
        return f"{self.name}在飞"

# 不能实例化抽象类
# animal = Animal("动物")  # TypeError

# 子类必须实现所有抽象方法
dog = Dog("旺财")
print(dog.speak())  # 旺财说: 汪汪!
print(dog.move())   # 旺财在跑
```

## 实战例子

### 例子1：员工管理系统

```python
from datetime import date

class Employee:
    """员工基类"""

    employee_count = 0

    def __init__(self, name, employee_id, hire_date):
        self.name = name
        self.employee_id = employee_id
        self.hire_date = hire_date
        Employee.employee_count += 1

    def get_info(self):
        """获取员工信息"""
        return f"员工: {self.name} (ID: {self.employee_id})"

    def calculate_salary(self):
        """计算工资（抽象方法，由子类实现）"""
        raise NotImplementedError("子类必须实现calculate_salary方法")

    def years_of_service(self):
        """工作年限"""
        today = date.today()
        years = today.year - self.hire_date.year
        return years

class SalariedEmployee(Employee):
    """固定工资员工"""

    def __init__(self, name, employee_id, hire_date, monthly_salary):
        super().__init__(name, employee_id, hire_date)
        self.monthly_salary = monthly_salary

    def calculate_salary(self):
        """计算月工资"""
        return self.monthly_salary

    def get_info(self):
        base_info = super().get_info()
        return f"{base_info} - 固定月薪: ¥{self.monthly_salary}"

class HourlyEmployee(Employee):
    """小时工"""

    def __init__(self, name, employee_id, hire_date, hourly_rate):
        super().__init__(name, employee_id, hire_date)
        self.hourly_rate = hourly_rate
        self.hours_worked = 0

    def log_hours(self, hours):
        """记录工作小时"""
        self.hours_worked += hours

    def calculate_salary(self):
        """计算工资"""
        salary = self.hours_worked * self.hourly_rate
        self.hours_worked = 0  # 重置
        return salary

    def get_info(self):
        base_info = super().get_info()
        return f"{base_info} - 时薪: ¥{self.hourly_rate}/小时"

class Manager(SalariedEmployee):
    """经理"""

    def __init__(self, name, employee_id, hire_date, monthly_salary, department):
        super().__init__(name, employee_id, hire_date, monthly_salary)
        self.department = department
        self.team = []

    def add_team_member(self, employee):
        """添加团队成员"""
        self.team.append(employee)
        print(f"{employee.name} 加入了 {self.name} 的团队")

    def calculate_salary(self):
        """经理工资 = 基本工资 + 团队奖金"""
        base_salary = super().calculate_salary()
        team_bonus = len(self.team) * 500
        return base_salary + team_bonus

    def get_info(self):
        return f"经理: {self.name} - 部门: {self.department}, 团队人数: {len(self.team)}"

# 使用
employees = [
    SalariedEmployee("张三", "E001", date(2020, 1, 15), 8000),
    HourlyEmployee("李四", "E002", date(2021, 3, 10), 50),
    Manager("王五", "M001", date(2019, 6, 1), 15000, "技术部")
]

# 李四工作了160小时
employees[1].log_hours(160)

# 王五管理两个员工
employees[2].add_team_member(employees[0])
employees[2].add_team_member(employees[1])

# 显示信息和工资
for emp in employees:
    print(emp.get_info())
    print(f"  本月工资: ¥{emp.calculate_salary()}")
    print(f"  工作年限: {emp.years_of_service()}年")
    print()
```

### 例子2：游戏角色系统

```python
import random

class Character:
    """游戏角色基类"""

    def __init__(self, name, level=1):
        self.name = name
        self.level = level
        self._hp = 100
        self._max_hp = 100
        self._mp = 50
        self._max_mp = 50
        self.attack = 10
        self.defense = 5

    @property
    def hp(self):
        return self._hp

    @hp.setter
    def hp(self, value):
        self._hp = max(0, min(value, self._max_hp))

    @property
    def mp(self):
        return self._mp

    @mp.setter
    def mp(self, value):
        self._mp = max(0, min(value, self._max_mp))

    def is_alive(self):
        """是否存活"""
        return self.hp > 0

    def take_damage(self, damage):
        """受到伤害"""
        actual_damage = max(1, damage - self.defense)
        self.hp -= actual_damage
        print(f"{self.name} 受到 {actual_damage} 点伤害! (HP: {self.hp}/{self._max_hp})")

        if not self.is_alive():
            print(f"{self.name} 被击败了!")

    def heal(self, amount):
        """恢复生命"""
        old_hp = self.hp
        self.hp += amount
        healed = self.hp - old_hp
        print(f"{self.name} 恢复了 {healed} 点HP")

    def basic_attack(self, target):
        """基础攻击"""
        damage = self.attack + random.randint(-2, 2)
        print(f"{self.name} 攻击 {target.name}!")
        target.take_damage(damage)

    def level_up(self):
        """升级"""
        self.level += 1
        self._max_hp += 20
        self._max_mp += 10
        self.attack += 3
        self.defense += 2
        self.hp = self._max_hp
        self.mp = self._max_mp
        print(f"{self.name} 升到了 {self.level} 级!")

class Warrior(Character):
    """战士"""

    def __init__(self, name, level=1):
        super().__init__(name, level)
        self._max_hp = 150
        self._hp = 150
        self.attack = 15
        self.defense = 10

    def power_strike(self, target):
        """猛击（消耗MP）"""
        mp_cost = 10
        if self.mp < mp_cost:
            print(f"{self.name} MP不足!")
            return

        self.mp -= mp_cost
        damage = self.attack * 2
        print(f"{self.name} 使用猛击!")
        target.take_damage(damage)

    def defensive_stance(self):
        """防御姿态"""
        self.defense += 5
        print(f"{self.name} 进入防御姿态! 防御+5")

class Mage(Character):
    """法师"""

    def __init__(self, name, level=1):
        super().__init__(name, level)
        self._max_hp = 80
        self._hp = 80
        self._max_mp = 100
        self._mp = 100
        self.attack = 8
        self.magic_power = 20

    def fireball(self, target):
        """火球术"""
        mp_cost = 15
        if self.mp < mp_cost:
            print(f"{self.name} MP不足!")
            return

        self.mp -= mp_cost
        damage = self.magic_power + random.randint(5, 15)
        print(f"{self.name} 释放火球术!")
        target.take_damage(damage)

    def heal_spell(self, target):
        """治疗术"""
        mp_cost = 20
        if self.mp < mp_cost:
            print(f"{self.name} MP不足!")
            return

        self.mp -= mp_cost
        heal_amount = 30 + random.randint(0, 10)
        print(f"{self.name} 释放治疗术!")
        target.heal(heal_amount)

class Archer(Character):
    """弓箭手"""

    def __init__(self, name, level=1):
        super().__init__(name, level)
        self._max_hp = 100
        self._hp = 100
        self.attack = 12
        self.critical_chance = 0.3  # 30%暴击率

    def aimed_shot(self, target):
        """瞄准射击"""
        mp_cost = 8
        if self.mp < mp_cost:
            print(f"{self.name} MP不足!")
            return

        self.mp -= mp_cost
        damage = self.attack

        # 判断是否暴击
        if random.random() < self.critical_chance:
            damage *= 2
            print(f"{self.name} 使用瞄准射击! 暴击!")
        else:
            print(f"{self.name} 使用瞄准射击!")

        target.take_damage(damage)

# 战斗示例
print("=== 战斗开始 ===\n")

warrior = Warrior("战士")
mage = Mage("法师")
archer = Archer("弓箭手")

# 回合1
warrior.power_strike(mage)
print()

# 回合2
mage.fireball(warrior)
print()

# 回合3
archer.aimed_shot(mage)
print()

# 回合4
mage.heal_spell(mage)
print()

# 查看状态
print("=== 当前状态 ===")
for char in [warrior, mage, archer]:
    print(f"{char.name}: HP {char.hp}/{char._max_hp}, MP {char.mp}/{char._max_mp}")
```

### 例子3：银行账户系统

```python
from datetime import datetime
from abc import ABC, abstractmethod

class Account(ABC):
    """账户抽象基类"""

    account_number_counter = 1000

    def __init__(self, owner, balance=0):
        self.account_number = Account.account_number_counter
        Account.account_number_counter += 1
        self.owner = owner
        self._balance = balance
        self.transactions = []
        self._log_transaction("开户", balance)

    @property
    def balance(self):
        return self._balance

    def _log_transaction(self, transaction_type, amount, balance=None):
        """记录交易"""
        if balance is None:
            balance = self._balance

        transaction = {
            "time": datetime.now(),
            "type": transaction_type,
            "amount": amount,
            "balance": balance
        }
        self.transactions.append(transaction)

    def deposit(self, amount):
        """存款"""
        if amount <= 0:
            print("存款金额必须大于0")
            return False

        self._balance += amount
        self._log_transaction("存款", amount)
        print(f"存款成功: ¥{amount}, 余额: ¥{self._balance}")
        return True

    def withdraw(self, amount):
        """取款"""
        if amount <= 0:
            print("取款金额必须大于0")
            return False

        if not self._can_withdraw(amount):
            print("取款失败")
            return False

        self._balance -= amount
        self._log_transaction("取款", amount)
        print(f"取款成功: ¥{amount}, 余额: ¥{self._balance}")
        return True

    @abstractmethod
    def _can_withdraw(self, amount):
        """检查是否可以取款（由子类实现）"""
        pass

    @abstractmethod
    def calculate_interest(self):
        """计算利息（由子类实现）"""
        pass

    def show_transactions(self, limit=10):
        """显示交易记录"""
        print(f"\n账户 {self.account_number} - {self.owner} 的交易记录:")
        print("-" * 60)

        recent = self.transactions[-limit:]
        for trans in recent:
            time_str = trans["time"].strftime("%Y-%m-%d %H:%M:%S")
            print(f"{time_str} | {trans['type']:6s} | "
                  f"¥{trans['amount']:8.2f} | 余额: ¥{trans['balance']:.2f}")

        print("-" * 60)
        print(f"当前余额: ¥{self._balance:.2f}\n")

class SavingsAccount(Account):
    """储蓄账户"""

    def __init__(self, owner, balance=0, interest_rate=0.03):
        super().__init__(owner, balance)
        self.interest_rate = interest_rate

    def _can_withdraw(self, amount):
        """储蓄账户不能透支"""
        if amount > self._balance:
            print(f"余额不足! 当前余额: ¥{self._balance}")
            return False
        return True

    def calculate_interest(self):
        """计算并添加利息"""
        interest = self._balance * self.interest_rate
        self._balance += interest
        self._log_transaction("利息", interest)
        print(f"利息 ¥{interest:.2f} 已添加")
        return interest

class CheckingAccount(Account):
    """支票账户（可透支）"""

    def __init__(self, owner, balance=0, overdraft_limit=1000):
        super().__init__(owner, balance)
        self.overdraft_limit = overdraft_limit

    def _can_withdraw(self, amount):
        """支票账户可以透支到一定限额"""
        if amount > self._balance + self.overdraft_limit:
            available = self._balance + self.overdraft_limit
            print(f"超过可用额度! 可用额度: ¥{available}")
            return False
        return True

    def calculate_interest(self):
        """支票账户无利息"""
        return 0

    def get_overdraft_amount(self):
        """获取透支金额"""
        if self._balance < 0:
            return abs(self._balance)
        return 0

# 使用
savings = SavingsAccount("张三", 10000, interest_rate=0.05)
checking = CheckingAccount("李四", 5000, overdraft_limit=2000)

# 储蓄账户操作
savings.deposit(2000)
savings.withdraw(3000)
savings.calculate_interest()
savings.show_transactions()

# 支票账户操作（可透支）
checking.withdraw(6000)  # 透支1000
print(f"透支金额: ¥{checking.get_overdraft_amount()}")
checking.deposit(3000)
checking.show_transactions()
```

## 常见陷阱

### 陷阱1：忘记调用父类__init__

```python
# ❌ 错误
class Parent:
    def __init__(self, name):
        self.name = name

class Child(Parent):
    def __init__(self, name, age):
        # 忘记调用父类__init__
        self.age = age

# child = Child("张三", 18)
# print(child.name)  # AttributeError

# ✅ 正确
class Child(Parent):
    def __init__(self, name, age):
        super().__init__(name)  # 调用父类
        self.age = age
```

### 陷阱2：多重继承的钻石问题

```python
class A:
    def method(self):
        print("A")

class B(A):
    def method(self):
        print("B")
        super().method()

class C(A):
    def method(self):
        print("C")
        super().method()

class D(B, C):
    def method(self):
        print("D")
        super().method()

d = D()
d.method()
# 输出: D B C A
# 遵循MRO顺序
```

## 练习题

### 练习1：形状类层次

创建形状类继承系统：
- Shape基类（抽象）
- Rectangle、Circle、Triangle子类
- 实现area()和perimeter()方法

### 练习2：车辆管理

创建车辆类系统：
- Vehicle基类
- Car、Motorcycle、Truck子类
- 实现燃油消耗计算

### 练习3：学校管理系统

创建完整的学校管理系统：
- Person基类
- Student、Teacher继承Person
- GraduateStudent继承Student

### 练习4：动物园模拟

创建动物园模拟系统：
- Animal抽象基类
- 各种动物子类
- 饲养员管理动物

## 下一步

学会了面向对象进阶，下一章我们学习常用内置模块！

[上一章：第20章 - 面向对象基础 ←](../20-面向对象基础/20-面向对象基础.md)

[下一章：第22章 - 常用内置模块 →](../22-常用内置模块/22-常用内置模块.md)

---

**本章重点**
- ✅ 掌握继承的概念和用法
- ✅ 使用super()调用父类方法
- ✅ 理解多态和鸭子类型
- ✅ 掌握封装和私有属性
- ✅ 使用@property装饰器
- ✅ 了解抽象基类
- ✅ 避免常见陷阱

**记住**
- 继承实现代码重用
- super()正确调用父类
- 多态提供灵活性
- 封装保护数据
- 抽象基类定义接口
- 组合优于继承（某些情况）
