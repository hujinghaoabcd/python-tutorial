# 第19章：异常处理

学习如何优雅地处理错误，让程序更健壮、用户体验更好。

## 什么是异常？

想象你在使用计算器，输入 `10 / 0`，会发生什么？程序直接崩溃？这样的用户体验太糟糕了！异常处理就是用来优雅地处理这些错误情况的。

**异常（Exception）** 是程序运行时发生的错误。如果不处理，程序就会崩溃。

```python
# 不处理异常 - 程序崩溃
result = 10 / 0  # ZeroDivisionError: division by zero
print("这行不会执行")

# 处理异常 - 程序继续运行
try:
    result = 10 / 0
except ZeroDivisionError:
    print("不能除以零")
    result = 0
print("程序继续运行")  # 这行会执行
```

### 为什么需要异常处理？

```python
# 没有异常处理的程序
def divide(a, b):
    return a / b

result = divide(10, 0)  # 崩溃！
print("后续代码不执行")

# 有异常处理的程序
def safe_divide(a, b):
    try:
        return a / b
    except ZeroDivisionError:
        print("除数不能为0")
        return None

result = safe_divide(10, 0)
print("程序正常继续")  # 继续运行
```

## 常见的异常类型

```python
# ZeroDivisionError - 除以零
try:
    result = 10 / 0
except ZeroDivisionError:
    print("不能除以零")

# ValueError - 值错误
try:
    number = int("abc")  # 无法转换
except ValueError:
    print("无效的数字格式")

# TypeError - 类型错误
try:
    result = "hello" + 5  # 字符串不能和数字相加
except TypeError:
    print("类型不匹配")

# FileNotFoundError - 文件不存在
try:
    with open("nonexistent.txt", "r") as f:
        content = f.read()
except FileNotFoundError:
    print("文件不存在")

# KeyError - 字典键不存在
try:
    data = {"name": "张三"}
    age = data["age"]  # 键不存在
except KeyError:
    print("键不存在")

# IndexError - 索引超出范围
try:
    numbers = [1, 2, 3]
    value = numbers[10]  # 索引超出范围
except IndexError:
    print("索引超出范围")

# AttributeError - 属性不存在
try:
    result = "hello".nonexistent_method()
except AttributeError:
    print("属性或方法不存在")

# ImportError - 导入失败
try:
    import nonexistent_module
except ImportError:
    print("模块不存在")
```

## try-except基础

### 基本语法

```python
try:
    # 可能出错的代码
    risky_code()
except ExceptionType:
    # 处理错误
    handle_error()
```

### 例子1：安全的除法

```python
def safe_divide(a, b):
    """安全的除法运算"""
    try:
        result = a / b
        return result
    except ZeroDivisionError:
        print("错误：除数不能为0")
        return None

print(safe_divide(10, 2))  # 5.0
print(safe_divide(10, 0))  # 错误：除数不能为0，返回None
```

### 例子2：安全的类型转换

```python
def safe_int(value):
    """安全地转换为整数"""
    try:
        return int(value)
    except ValueError:
        print(f"无法将 '{value}' 转换为整数")
        return None

print(safe_int("123"))    # 123
print(safe_int("abc"))    # 无法将 'abc' 转换为整数，返回None
print(safe_int("12.5"))   # 无法将 '12.5' 转换为整数，返回None
```

## 捕获多个异常

### 方法1：多个except块

```python
try:
    value = input("输入数字: ")
    number = int(value)
    result = 10 / number
    print(f"结果：{result}")
except ValueError:
    print("输入的不是数字")
except ZeroDivisionError:
    print("除数不能为0")
```

### 方法2：同时捕获多个异常

```python
try:
    # 可能引发多种异常
    operation()
except (ValueError, TypeError, KeyError):
    print("发生了值错误、类型错误或键错误")

# 获取异常信息
try:
    operation()
except (ValueError, TypeError) as e:
    print(f"错误类型：{type(e).__name__}")
    print(f"错误信息：{e}")
```

### 例子：用户输入验证

```python
def get_positive_integer():
    """获取正整数"""
    while True:
        try:
            value = input("请输入正整数: ")
            number = int(value)

            if number <= 0:
                print("必须是正数，请重试")
                continue

            return number
        except ValueError:
            print("输入无效，请输入整数")
        except KeyboardInterrupt:
            print("\n用户取消输入")
            return None

# 使用
number = get_positive_integer()
if number:
    print(f"你输入的是：{number}")
```

## try-except-else-finally

完整的异常处理结构：

```python
try:
    # 可能出错的代码
    risky_operation()
except ExceptionType:
    # 处理异常
    handle_error()
else:
    # 没有异常时执行
    success_handling()
finally:
    # 无论如何都执行（清理资源）
    cleanup()
```

### else子句

```python
try:
    number = int(input("输入数字: "))
except ValueError:
    print("输入无效")
else:
    # 只有当没有异常时才执行
    print(f"你输入的数字是：{number}")
    print(f"它的平方是：{number ** 2}")
```

### finally子句

```python
# finally总是执行，常用于清理资源
def read_file(filename):
    """读取文件，确保文件被关闭"""
    file = None
    try:
        file = open(filename, "r")
        content = file.read()
        return content
    except FileNotFoundError:
        print(f"文件 {filename} 不存在")
        return None
    finally:
        # 无论是否出错，都关闭文件
        if file:
            file.close()
            print("文件已关闭")
```

### 完整例子：数据库操作

```python
class Database:
    """模拟数据库连接"""

    def __init__(self, name):
        self.name = name
        self.connected = False

    def connect(self):
        print(f"连接到数据库：{self.name}")
        self.connected = True

    def query(self, sql):
        if not self.connected:
            raise Exception("数据库未连接")
        print(f"执行查询：{sql}")
        return ["结果1", "结果2"]

    def close(self):
        print(f"关闭数据库连接：{self.name}")
        self.connected = False

def query_database(sql):
    """查询数据库"""
    db = Database("mydb")
    try:
        db.connect()
        results = db.query(sql)
        return results
    except Exception as e:
        print(f"查询失败：{e}")
        return None
    else:
        print("查询成功")
    finally:
        # 无论成功失败，都关闭连接
        db.close()

# 使用
results = query_database("SELECT * FROM users")
```

## 捕获所有异常

### 使用Exception

```python
try:
    # 危险操作
    risky_operation()
except Exception as e:
    # 捕获所有异常（除了SystemExit、KeyboardInterrupt等）
    print(f"发生错误：{type(e).__name__}: {e}")
```

### 使用裸except（不推荐）

```python
# ⚠️ 不推荐 - 会捕获所有异常，包括系统异常
try:
    something()
except:
    print("发生错误")  # 无法知道具体错误

# ✅ 推荐 - 捕获Exception
try:
    something()
except Exception as e:
    print(f"发生错误：{e}")
```

## 抛出异常

### 使用raise

```python
def divide(a, b):
    """除法，除数为0时抛出异常"""
    if b == 0:
        raise ValueError("除数不能为0")
    return a / b

try:
    result = divide(10, 0)
except ValueError as e:
    print(f"错误：{e}")  # 错误：除数不能为0
```

### 重新抛出异常

```python
def process_data(data):
    """处理数据"""
    try:
        # 处理逻辑
        result = risky_operation(data)
        return result
    except ValueError as e:
        # 记录日志
        print(f"记录错误：{e}")
        # 重新抛出异常，让调用者处理
        raise

try:
    process_data(invalid_data)
except ValueError:
    print("调用者捕获了重新抛出的异常")
```

### 抛出不同的异常

```python
def get_user_age(user_id):
    """获取用户年龄"""
    try:
        # 从数据库获取
        user = database.get(user_id)
        return user["age"]
    except KeyError:
        # 将KeyError转换为更有意义的异常
        raise ValueError(f"用户 {user_id} 的年龄数据缺失")

try:
    age = get_user_age(123)
except ValueError as e:
    print(e)
```

## 自定义异常

### 创建自定义异常类

```python
class InsufficientFundsError(Exception):
    """余额不足异常"""
    pass

class NegativeAmountError(Exception):
    """负数金额异常"""
    pass

class BankAccount:
    """银行账户"""

    def __init__(self, owner, balance=0):
        self.owner = owner
        self.balance = balance

    def deposit(self, amount):
        """存款"""
        if amount < 0:
            raise NegativeAmountError("存款金额不能为负数")
        self.balance += amount

    def withdraw(self, amount):
        """取款"""
        if amount < 0:
            raise NegativeAmountError("取款金额不能为负数")
        if amount > self.balance:
            raise InsufficientFundsError(
                f"余额不足，当前余额：¥{self.balance}，需要：¥{amount}"
            )
        self.balance -= amount

# 使用
account = BankAccount("张三", 1000)

try:
    account.withdraw(1500)
except InsufficientFundsError as e:
    print(f"取款失败：{e}")

try:
    account.deposit(-100)
except NegativeAmountError as e:
    print(f"存款失败：{e}")
```

### 带更多信息的自定义异常

```python
class ValidationError(Exception):
    """数据验证异常"""

    def __init__(self, field, message):
        self.field = field
        self.message = message
        super().__init__(f"字段 '{field}' 验证失败：{message}")

class User:
    """用户类"""

    def __init__(self, username, age, email):
        self.username = username
        self.age = age
        self.email = email
        self.validate()

    def validate(self):
        """验证用户数据"""
        if len(self.username) < 3:
            raise ValidationError("username", "用户名至少3个字符")

        if self.age < 0 or self.age > 150:
            raise ValidationError("age", "年龄必须在0-150之间")

        if "@" not in self.email:
            raise ValidationError("email", "邮箱格式不正确")

# 使用
try:
    user = User("ab", 25, "test@example.com")
except ValidationError as e:
    print(f"验证失败：{e}")
    print(f"错误字段：{e.field}")
    print(f"错误信息：{e.message}")
```

## 实战例子

### 例子1：安全的文件操作

```python
def safe_read_file(filename, default=""):
    """安全地读取文件"""
    try:
        with open(filename, "r", encoding="utf-8") as f:
            return f.read()
    except FileNotFoundError:
        print(f"文件不存在：{filename}")
        return default
    except PermissionError:
        print(f"没有权限读取：{filename}")
        return default
    except UnicodeDecodeError:
        print(f"文件编码错误：{filename}")
        # 尝试其他编码
        try:
            with open(filename, "r", encoding="gbk") as f:
                return f.read()
        except:
            return default
    except Exception as e:
        print(f"未知错误：{e}")
        return default

# 使用
content = safe_read_file("config.txt", default="# 默认配置")
print(content)
```

### 例子2：网络请求重试

```python
import time

def fetch_data(url, max_retries=3, timeout=5):
    """
    获取数据，失败时自动重试
    """
    import random  # 模拟网络请求

    for attempt in range(max_retries):
        try:
            print(f"尝试第 {attempt + 1} 次...")

            # 模拟网络请求
            if random.random() < 0.7:  # 70%失败率
                raise ConnectionError("网络连接失败")

            # 成功获取数据
            data = {"status": "success", "data": [1, 2, 3]}
            print("获取成功")
            return data

        except ConnectionError as e:
            print(f"连接失败：{e}")

            if attempt < max_retries - 1:
                wait_time = 2 ** attempt  # 指数退避
                print(f"等待 {wait_time} 秒后重试...")
                time.sleep(wait_time)
            else:
                print("达到最大重试次数")
                return None

        except Exception as e:
            print(f"未知错误：{e}")
            return None

# 使用
data = fetch_data("https://api.example.com/data")
if data:
    print(f"获取的数据：{data}")
else:
    print("获取数据失败")
```

### 例子3：用户输入验证

```python
class InputValidator:
    """输入验证器"""

    @staticmethod
    def get_integer(prompt, min_value=None, max_value=None):
        """获取整数输入"""
        while True:
            try:
                value = int(input(prompt))

                if min_value is not None and value < min_value:
                    print(f"值必须 >= {min_value}")
                    continue

                if max_value is not None and value > max_value:
                    print(f"值必须 <= {max_value}")
                    continue

                return value

            except ValueError:
                print("请输入有效的整数")
            except KeyboardInterrupt:
                print("\n操作已取消")
                return None

    @staticmethod
    def get_float(prompt, positive=False):
        """获取浮点数输入"""
        while True:
            try:
                value = float(input(prompt))

                if positive and value <= 0:
                    print("值必须为正数")
                    continue

                return value

            except ValueError:
                print("请输入有效的数字")
            except KeyboardInterrupt:
                print("\n操作已取消")
                return None

    @staticmethod
    def get_choice(prompt, choices):
        """获取选择（从列表中）"""
        while True:
            print(prompt)
            for i, choice in enumerate(choices, 1):
                print(f"{i}. {choice}")

            try:
                index = int(input("请选择(输入数字): ")) - 1

                if 0 <= index < len(choices):
                    return choices[index]
                else:
                    print("无效的选择")

            except ValueError:
                print("请输入数字")
            except KeyboardInterrupt:
                print("\n操作已取消")
                return None

# 使用
age = InputValidator.get_integer("请输入年龄: ", min_value=0, max_value=150)
price = InputValidator.get_float("请输入价格: ", positive=True)
fruit = InputValidator.get_choice("选择水果:", ["苹果", "香蕉", "橙子"])

print(f"年龄：{age}，价格：{price}，水果：{fruit}")
```

### 例子4：配置文件加载

```python
import json

class ConfigLoader:
    """配置文件加载器"""

    def __init__(self, filename):
        self.filename = filename
        self.config = {}

    def load(self):
        """加载配置"""
        try:
            with open(self.filename, "r", encoding="utf-8") as f:
                self.config = json.load(f)
            print(f"配置加载成功：{self.filename}")
            return True

        except FileNotFoundError:
            print(f"配置文件不存在：{self.filename}")
            self._create_default_config()
            return False

        except json.JSONDecodeError as e:
            print(f"配置文件格式错误：{e}")
            return False

        except Exception as e:
            print(f"加载配置失败：{e}")
            return False

    def _create_default_config(self):
        """创建默认配置"""
        default_config = {
            "host": "localhost",
            "port": 8080,
            "debug": True
        }

        try:
            with open(self.filename, "w", encoding="utf-8") as f:
                json.dump(default_config, f, indent=2)
            print(f"已创建默认配置：{self.filename}")
            self.config = default_config
        except Exception as e:
            print(f"创建默认配置失败：{e}")

    def get(self, key, default=None):
        """获取配置项"""
        return self.config.get(key, default)

# 使用
config = ConfigLoader("app_config.json")
if config.load():
    host = config.get("host")
    port = config.get("port")
    print(f"服务器：{host}:{port}")
```

### 例子5：批量处理任务

```python
def process_batch(items):
    """
    批量处理任务，记录成功和失败
    """
    results = {
        "success": [],
        "failed": []
    }

    for i, item in enumerate(items):
        try:
            # 处理单个项目
            result = process_item(item)
            results["success"].append({
                "index": i,
                "item": item,
                "result": result
            })

        except ValueError as e:
            # 记录失败的项目
            results["failed"].append({
                "index": i,
                "item": item,
                "error": str(e),
                "type": "ValueError"
            })

        except Exception as e:
            results["failed"].append({
                "index": i,
                "item": item,
                "error": str(e),
                "type": type(e).__name__
            })

    return results

def process_item(item):
    """处理单个项目（模拟）"""
    if not isinstance(item, (int, float)):
        raise ValueError(f"无效的数据类型：{type(item)}")
    if item < 0:
        raise ValueError("值不能为负数")
    return item * 2

# 使用
items = [10, 20, -5, "abc", 30, None, 40]
results = process_batch(items)

print(f"成功：{len(results['success'])} 个")
print(f"失败：{len(results['failed'])} 个")

print("\n失败的项目：")
for failed in results["failed"]:
    print(f"  索引 {failed['index']}: {failed['item']} - {failed['error']}")
```

## 常见陷阱

### 陷阱1：捕获异常后吞掉错误

```python
# ❌ 错误 - 捕获后什么都不做
try:
    important_operation()
except:
    pass  # 错误被吞掉，无法调试

# ✅ 正确 - 至少记录错误
try:
    important_operation()
except Exception as e:
    print(f"操作失败：{e}")
    # 或者记录到日志
    logging.error(f"操作失败：{e}")
```

### 陷阱2：捕获范围过大

```python
# ❌ 错误 - 捕获所有异常
try:
    value = int(input())
    result = 10 / value
except:  # 连KeyboardInterrupt都捕获了
    print("出错了")

# ✅ 正确 - 只捕获特定异常
try:
    value = int(input())
    result = 10 / value
except ValueError:
    print("输入无效")
except ZeroDivisionError:
    print("不能除以0")
```

### 陷阱3：异常处理代码中又出错

```python
# ❌ 危险 - except块中可能出错
try:
    value = data["key"]
except KeyError:
    # 这里可能引发另一个异常
    log_error(undefined_variable)  # NameError!

# ✅ 正确 - 确保except块安全
try:
    value = data["key"]
except KeyError as e:
    # 安全的错误处理
    error_message = str(e)
    print(f"键不存在：{error_message}")
```

### 陷阱4：finally中return

```python
# ❌ 错误 - finally中return会覆盖异常
def bad_function():
    try:
        return 1 / 0
    finally:
        return "finally"  # 异常被吞掉！

result = bad_function()  # 返回 "finally"，没有抛出异常

# ✅ 正确 - finally只做清理
def good_function():
    try:
        return 1 / 0
    finally:
        print("清理资源")  # 只做清理，不return
```

## 最佳实践

### 1. 捕获具体的异常

```python
# ✅ 好
try:
    value = int(user_input)
except ValueError:
    handle_invalid_input()

# ❌ 不好
try:
    value = int(user_input)
except:
    handle_error()  # 太宽泛
```

### 2. 不要忽略异常

```python
# ❌ 不好
try:
    operation()
except Exception:
    pass  # 忽略所有错误

# ✅ 好
try:
    operation()
except Exception as e:
    logger.error(f"操作失败：{e}")
```

### 3. 在合适的层级处理异常

```python
# ✅ 好 - 在合适的层级处理
def low_level_function():
    # 不处理，让上层决定
    return int(value)

def high_level_function():
    try:
        result = low_level_function()
        return result
    except ValueError:
        # 在这里处理更合适
        show_error_to_user("输入无效")
        return None
```

### 4. 使用上下文管理器

```python
# ✅ 好 - 自动清理
with open("file.txt", "r") as f:
    content = f.read()
# 文件自动关闭

# 而不是
f = open("file.txt", "r")
try:
    content = f.read()
finally:
    f.close()
```

### 5. 提供有用的错误信息

```python
# ❌ 不好
raise ValueError("Error")

# ✅ 好
raise ValueError(f"无效的年龄值：{age}，必须在0-150之间")
```

## 调试技巧

### 打印异常的详细信息

```python
import traceback

try:
    problematic_code()
except Exception as e:
    # 打印异常类型和消息
    print(f"异常类型：{type(e).__name__}")
    print(f"异常消息：{e}")

    # 打印完整的堆栈跟踪
    traceback.print_exc()

    # 或获取堆栈跟踪的字符串
    trace = traceback.format_exc()
    print(trace)
```

## 练习题

### 练习1：安全计算器

实现一个安全的计算器，处理：
- 除以零
- 无效输入
- 未知运算符

### 练习2：文件处理工具

创建一个文件处理工具，处理：
- 文件不存在
- 权限错误
- 编码错误
- 磁盘满

### 练习3：自定义异常系统

为一个在线商店创建异常系统：
- `ProductNotFoundError`
- `OutOfStockError`
- `InvalidQuantityError`
- `PaymentFailedError`

### 练习4：带重试的API调用

实现一个API调用函数：
- 自动重试失败的请求
- 指数退避
- 记录每次重试
- 最终失败时返回有意义的错误

### 练习5：数据验证器

创建一个数据验证类：
- 验证邮箱、电话、身份证
- 抛出自定义的验证异常
- 提供详细的错误信息

## 下一步

学会了异常处理，下一章我们学习面向对象编程，用类和对象组织代码！

[上一章：第18章 - 文件读写 ←](../18-文件读写/18-文件读写.md)

[下一章：第20章 - 面向对象基础 →](../20-面向对象基础/20-面向对象基础.md)

---

**本章重点**
- ✅ 理解异常的概念
- ✅ 掌握try-except-else-finally
- ✅ 捕获和处理常见异常
- ✅ 抛出和自定义异常
- ✅ 异常处理最佳实践
- ✅ 避免常见陷阱

**记住**
- 只捕获你能处理的异常
- 提供有用的错误信息
- 不要忽略异常
- 在合适的层级处理异常
- 使用具体的异常类型
- finally用于清理资源
