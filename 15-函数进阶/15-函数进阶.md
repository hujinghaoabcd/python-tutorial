# 第15章：函数进阶

深入学习函数的各种高级用法。

## 为什么需要进阶功能？

### 从生活中理解

上一章我们学会了函数的基础，就像学会了做基本的家常菜。现在，我们要学习一些"烹饪技巧"，让你的"厨艺"更上一层楼！

**场景1：参数数量不确定**

想象你开了一家餐厅，有个"合菜"功能：

```python
# 问题：客人点菜数量不固定
# 有时2个菜，有时5个菜，有时10个菜

# ❌ 基础方法：为每种情况写一个函数
def calculate_total_2_dishes(price1, price2):
    return price1 + price2

def calculate_total_3_dishes(price1, price2, price3):
    return price1 + price2 + price3

def calculate_total_4_dishes(price1, price2, price3, price4):
    return price1 + price2 + price3 + price4

# 要写100个函数？！

# ✅ 进阶方法：用可变参数
def calculate_total(*prices):
    """不管多少个菜，一个函数搞定！"""
    return sum(prices)

# 2个菜
total = calculate_total(25.0, 30.0)  # 55.0

# 5个菜
total = calculate_total(25.0, 30.0, 15.0, 40.0, 20.0)  # 130.0

# 想加多少菜都行！
```

**场景2：配置选项很多**

就像点奶茶，每个人的要求都不一样：

```python
# 问题：每个人要求不同
# 有人要：大杯、少糖、加珍珠
# 有人要：中杯、去冰、加椰果、加布丁

# ❌ 基础方法：参数太多了
def make_milk_tea(size, sugar, ice, pearl, coconut, pudding, red_bean, grass_jelly):
    # 8个参数！调用时要全写上，烦死了
    pass

make_milk_tea("大杯", "少糖", "正常冰", True, False, False, False, False)

# ✅ 进阶方法：用关键字参数
def make_milk_tea(size, **toppings):
    """想加什么配料就加什么！"""
    print(f"制作{size}奶茶")
    for topping, want in toppings.items():
        if want:
            print(f"  加{topping}")

# 简单！想要什么就传什么
make_milk_tea("大杯", pearl=True)  # 只加珍珠
make_milk_tea("中杯", coconut=True, pudding=True)  # 加椰果和布丁
```

### 本章要学什么？

1. **可变参数（*args, **kwargs）** - 处理不确定数量的参数
2. **参数解包（* 和 **）** - 把列表/字典展开成参数
3. **作用域** - 变量的"势力范围"
4. **闭包** - 函数里包着函数
5. **装饰器** - 给函数"加功能"
6. **匿名函数** - 简短的一次性函数

每个都很实用！让我们开始吧！

## 可变参数

### *args - 任意数量的位置参数

```python
def sum_all(*args):
    """计算所有参数的和"""
    total = 0
    for num in args:
        total += num
    return total

print(sum_all(1, 2, 3))  # 6
print(sum_all(1, 2, 3, 4, 5))  # 15
print(sum_all())  # 0

# args是一个元组
def print_args(*args):
    print(type(args))  # <class 'tuple'>
    print(args)

print_args(1, 2, 3)  # (1, 2, 3)
```

### **kwargs - 任意数量的关键字参数

```python
def print_info(**kwargs):
    """打印所有关键字参数"""
    for key, value in kwargs.items():
        print(f"{key}: {value}")

print_info(name="张三", age=25, city="北京")
# name: 张三
# age: 25
# city: 北京

# kwargs是一个字典
def show_kwargs(**kwargs):
    print(type(kwargs))  # <class 'dict'>
    print(kwargs)

show_kwargs(a=1, b=2)  # {'a': 1, 'b': 2}
```

### 组合使用

```python
def func(a, b, *args, **kwargs):
    print(f"a = {a}")
    print(f"b = {b}")
    print(f"args = {args}")
    print(f"kwargs = {kwargs}")

func(1, 2, 3, 4, 5, x=10, y=20)
# a = 1
# b = 2
# args = (3, 4, 5)
# kwargs = {'x': 10, 'y': 20}
```

**参数顺序规则**：
1. 普通参数
2. *args
3. 默认参数
4. **kwargs

```python
def complex_func(a, b, *args, c=10, **kwargs):
    pass
```

## 参数解包

### 列表/元组解包（*）

```python
def add(a, b, c):
    return a + b + c

numbers = [1, 2, 3]
result = add(*numbers)  # 等价于 add(1, 2, 3)
print(result)  # 6

# 元组也可以
nums = (4, 5, 6)
print(add(*nums))  # 15
```

### 字典解包（**）

```python
def greet(name, age, city):
    print(f"{name}, {age}岁, 来自{city}")

person = {"name": "张三", "age": 25, "city": "北京"}
greet(**person)  # 等价于 greet(name="张三", age=25, city="北京")
```

## 强制关键字参数

Python 3中，可以强制某些参数必须用关键字传递。

```python
# *后面的参数必须用关键字
def func(a, b, *, c, d):
    print(a, b, c, d)

func(1, 2, c=3, d=4)  # 正确
# func(1, 2, 3, 4)  # 错误：c和d必须用关键字
```

## 仅限位置参数（Python 3.8+）

```python
# /前面的参数只能用位置传递
def func(a, b, /, c, d):
    print(a, b, c, d)

func(1, 2, 3, 4)  # 正确
func(1, 2, c=3, d=4)  # 正确
# func(a=1, b=2, c=3, d=4)  # 错误：a和b只能用位置
```

## 函数注解

给参数和返回值添加类型提示（仅提示，不强制）。

```python
def greet(name: str, age: int) -> str:
    return f"{name}, {age}岁"

# 依然可以传其他类型（只是提示）
print(greet("张三", 25))
print(greet(123, "abc"))  # 也能运行，但不推荐
```

## 匿名函数（lambda）

简单的单行函数。

```python
# 普通函数
def square(x):
    return x ** 2

# lambda函数
square = lambda x: x ** 2

print(square(5))  # 25

# 多个参数
add = lambda a, b: a + b
print(add(3, 5))  # 8

# 常用于sort、map、filter等
numbers = [(1, 2), (4, 1), (3, 3)]
numbers.sort(key=lambda x: x[1])  # 按第二个元素排序
print(numbers)  # [(4, 1), (1, 2), (3, 3)]
```

**lambda vs 普通函数**：
- lambda适合简单的单行函数
- 复杂逻辑用def

## 闭包

函数内部定义的函数，可以访问外部函数的变量。

```python
def outer(x):
    def inner(y):
        return x + y  # 访问外部变量x
    return inner

add_5 = outer(5)
print(add_5(3))  # 8
print(add_5(10))  # 15
```

### 闭包的应用

```python
def make_multiplier(n):
    """创建乘法器"""
    def multiplier(x):
        return x * n
    return multiplier

times_2 = make_multiplier(2)
times_3 = make_multiplier(3)

print(times_2(5))  # 10
print(times_3(5))  # 15
```

## 装饰器基础

装饰器是修改函数行为的高级技巧。

```python
def timer(func):
    """计时装饰器"""
    import time
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"{func.__name__}用时: {end - start:.3f}秒")
        return result
    return wrapper

# 使用装饰器
@timer
def slow_function():
    import time
    time.sleep(1)
    return "完成"

slow_function()  # slow_function用时: 1.001秒
```

## 内置高阶函数

### map() - 映射

```python
# 对每个元素应用函数
numbers = [1, 2, 3, 4, 5]
squared = map(lambda x: x ** 2, numbers)
print(list(squared))  # [1, 4, 9, 16, 25]

# 多个可迭代对象
a = [1, 2, 3]
b = [10, 20, 30]
result = map(lambda x, y: x + y, a, b)
print(list(result))  # [11, 22, 33]
```

### filter() - 过滤

```python
# 保留满足条件的元素
numbers = [1, 2, 3, 4, 5, 6]
even = filter(lambda x: x % 2 == 0, numbers)
print(list(even))  # [2, 4, 6]
```

### reduce() - 归约

```python
from functools import reduce

# 累积计算
numbers = [1, 2, 3, 4, 5]
total = reduce(lambda x, y: x + y, numbers)
print(total)  # 15

# 等价于
total = 0
for num in numbers:
    total = total + num
```

### sorted() - 排序

```python
# 按长度排序
words = ["apple", "pie", "banana", "cherry"]
sorted_words = sorted(words, key=lambda x: len(x))
print(sorted_words)  # ['pie', 'apple', 'banana', 'cherry']

# 按多个条件
students = [
    ("张三", 85),
    ("李四", 92),
    ("王五", 85),
    ("赵六", 78)
]
# 先按分数降序，再按姓名升序
sorted_students = sorted(students, key=lambda x: (-x[1], x[0]))
print(sorted_students)
```

## 偏函数

固定某些参数的函数。

```python
from functools import partial

def power(base, exponent):
    return base ** exponent

# 创建平方函数
square = partial(power, exponent=2)
print(square(5))  # 25

# 创建立方函数
cube = partial(power, exponent=3)
print(cube(5))  # 125
```

## 实战例子

### 例子1：日志装饰器

```python
def log(func):
    """记录函数调用"""
    def wrapper(*args, **kwargs):
        print(f"调用 {func.__name__}")
        print(f"参数: {args}, {kwargs}")
        result = func(*args, **kwargs)
        print(f"返回: {result}")
        return result
    return wrapper

@log
def add(a, b):
    return a + b

add(3, 5)
# 调用 add
# 参数: (3, 5), {}
# 返回: 8
```

### 例子2：缓存装饰器

```python
def memoize(func):
    """缓存函数结果"""
    cache = {}
    def wrapper(*args):
        if args not in cache:
            cache[args] = func(*args)
        return cache[args]
    return wrapper

@memoize
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

# 第二次调用会很快（使用缓存）
print(fibonacci(35))
```

### 例子3：重试机制

```python
def retry(max_attempts=3):
    """重试装饰器"""
    def decorator(func):
        def wrapper(*args, **kwargs):
            for attempt in range(max_attempts):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    print(f"尝试 {attempt + 1} 失败: {e}")
                    if attempt == max_attempts - 1:
                        raise
        return wrapper
    return decorator

@retry(max_attempts=3)
def unstable_function():
    import random
    if random.random() < 0.7:
        raise Exception("随机失败")
    return "成功"
```

### 例子4：参数验证

```python
def validate_positive(func):
    """验证参数为正数"""
    def wrapper(*args, **kwargs):
        for arg in args:
            if isinstance(arg, (int, float)) and arg <= 0:
                raise ValueError("参数必须为正数")
        return func(*args, **kwargs)
    return wrapper

@validate_positive
def calculate_interest(principal, rate):
    return principal * rate / 100

try:
    print(calculate_interest(1000, 5))  # 50.0
    print(calculate_interest(-1000, 5))  # ValueError
except ValueError as e:
    print(e)
```

### 例子5：函数组合

```python
def compose(*functions):
    """组合多个函数"""
    def inner(arg):
        result = arg
        for func in reversed(functions):
            result = func(result)
        return result
    return inner

def double(x):
    return x * 2

def increment(x):
    return x + 1

def square(x):
    return x ** 2

# f(g(h(x)))
combined = compose(square, increment, double)
print(combined(3))  # square(increment(double(3))) = square(7) = 49
```

### 例子6：柯里化

```python
def curry(func):
    """柯里化函数"""
    def curried(*args):
        if len(args) >= func.__code__.co_argcount:
            return func(*args)
        return lambda *more: curried(*(args + more))
    return curried

@curry
def add_three(a, b, c):
    return a + b + c

# 可以分步调用
print(add_three(1)(2)(3))  # 6
print(add_three(1, 2)(3))  # 6
print(add_three(1, 2, 3))  # 6
```

### 例子7：计数器

```python
def make_counter():
    """创建计数器"""
    count = 0
    def counter():
        nonlocal count  # 修改外部变量
        count += 1
        return count
    return counter

c1 = make_counter()
print(c1())  # 1
print(c1())  # 2
print(c1())  # 3

c2 = make_counter()
print(c2())  # 1（独立的计数器）
```

### 例子8：权限检查

```python
def require_auth(func):
    """需要认证"""
    def wrapper(user, *args, **kwargs):
        if not user.get("is_authenticated"):
            raise PermissionError("需要登录")
        return func(user, *args, **kwargs)
    return wrapper

@require_auth
def delete_post(user, post_id):
    return f"用户{user['name']}删除了帖子{post_id}"

# 测试
authenticated_user = {"name": "张三", "is_authenticated": True}
guest = {"name": "游客", "is_authenticated": False}

print(delete_post(authenticated_user, 123))
try:
    delete_post(guest, 123)
except PermissionError as e:
    print(e)
```

## 常见陷阱

### 陷阱1：默认参数是可变对象

```python
# 错误
def add_item(item, list=[]):
    list.append(item)
    return list

print(add_item(1))  # [1]
print(add_item(2))  # [1, 2] 不是[2]！

# 正确
def add_item(item, list=None):
    if list is None:
        list = []
    list.append(item)
    return list
```

### 陷阱2：闭包中的变量

```python
# 错误
functions = []
for i in range(3):
    functions.append(lambda: i)

for f in functions:
    print(f())  # 2, 2, 2（都是2！）

# 正确
functions = []
for i in range(3):
    functions.append(lambda x=i: x)

for f in functions:
    print(f())  # 0, 1, 2
```

### 陷阱3：*args和**kwargs的位置

```python
# 错误
def func(**kwargs, *args):  # SyntaxError
    pass

# 正确
def func(*args, **kwargs):
    pass
```

## 练习题

### 练习1：可变参数函数

编写一个函数，接受任意数量的数字，返回它们的平均值。

### 练习2：装饰器

编写一个装饰器，统计函数被调用的次数。

### 练习3：高阶函数

使用map和filter找出列表中所有偶数的平方。

### 练习4：闭包

创建一个账户类（用闭包实现），支持存款、取款、查询余额。

### 练习5：柯里化

实现一个通用的柯里化函数。

## 下一步

学会了函数进阶，下一章我们学习Lambda和高阶函数的更多应用！

[上一章：第14章 - 函数基础 ←](../14-函数基础/14-函数基础.md)

[下一章：第16章 - Lambda和高阶函数 →](../16-Lambda和高阶函数/16-Lambda和高阶函数.md)

---

**本章重点**
- ✅ *args和**kwargs可变参数
- ✅ 参数解包（*和**）
- ✅ lambda匿名函数
- ✅ 闭包和作用域
- ✅ 装饰器基础
- ✅ map、filter、reduce高阶函数

**记住**
- *args收集位置参数为元组
- **kwargs收集关键字参数为字典
- lambda适合简单函数
- 闭包可以保存状态
- 装饰器用@语法
- 默认参数不要用可变对象
