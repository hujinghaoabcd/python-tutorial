# 第18章:文件读写

学习如何读写文件,处理数据持久化,让程序能够保存和读取数据,实现真正有用的应用程序。

## 为什么需要文件操作?一个真实的故事

想象一下这个场景:你花了一整天时间玩一个RPG游戏,好不容易升到了50级,装备齐全,正准备去挑战最终BOSS。这时候你的朋友叫你出去吃饭,你关闭了游戏。吃完饭回来,打开游戏,发现...所有进度都没了!你又回到了1级,所有努力白费!

这就是**没有文件操作**的后果。

程序运行时,所有数据都存储在**内存(RAM)**中。内存就像你的工作台,可以快速存取东西,但有个致命缺陷:**一断电就全没了**。你关闭程序,或者电脑重启,内存里的数据就会被清空,就像桌子被收拾干净了一样。

```python
# 没有文件操作的程序
score = 100
level = 50
items = ["宝剑", "盔甲", "药水"]

# 程序运行时这些数据在内存中
print(f"当前分数: {score}")
print(f"当前等级: {level}")

# 但是一旦程序关闭...这些数据全部消失!
# 下次运行程序时,score又变回了初始值
```

**文件操作**就是用来解决这个问题的!文件存储在**硬盘**上,就像把东西放进保险柜,关机后数据依然存在:

```python
# 使用文件操作 - 数据持久化
score = 100
level = 50

# 保存到文件
with open("game_save.txt", "w") as f:
    f.write(f"{score}\n")
    f.write(f"{level}\n")

print("游戏进度已保存!")

# 下次运行程序时,可以读取之前保存的数据
with open("game_save.txt", "r") as f:
    saved_score = int(f.readline().strip())
    saved_level = int(f.readline().strip())

print(f"读取进度: 分数={saved_score}, 等级={saved_level}")
# 完美!数据还在!
```

### 文件操作的实际应用 - 无处不在

文件操作不仅仅用于游戏存档,实际上你每天使用的几乎所有程序都在用文件操作:

#### 1. 配置文件 - 保存程序设置

你有没有注意到,当你调整了某个软件的设置(比如主题、字体大小、快捷键)后,下次打开软件时这些设置还在?这就是文件操作的功劳!

```python
# 保存用户设置到配置文件
settings = {
    "theme": "dark",
    "font_size": 14,
    "auto_save": True
}

# 写入配置文件
with open("config.txt", "w") as f:
    for key, value in settings.items():
        f.write(f"{key}={value}\n")

# 下次启动时读取配置
# 配置文件内容:
# theme=dark
# font_size=14
# auto_save=True
```

实际例子:
- **浏览器**: 保存你的书签、历史记录、Cookie
- **代码编辑器**: 保存你的配置、快捷键设置、最近打开的文件
- **音乐播放器**: 保存播放列表、歌词文件
- **游戏**: 保存存档、设置、键位配置

#### 2. 日志文件 - 记录程序运行情况

当程序出错时,开发者怎么知道发生了什么?靠的就是日志文件!程序运行时会把重要事件记录到日志文件中,就像飞机的黑匣子。

```python
# 记录日志
from datetime import datetime

def log_event(message, level="INFO"):
    """记录事件到日志文件"""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    log_line = f"[{timestamp}] [{level}] {message}\n"

    with open("app.log", "a") as f:  # 'a' 表示追加
        f.write(log_line)

# 程序运行时记录各种事件
log_event("程序启动")
log_event("用户登录: 张三")
log_event("数据库连接成功")
log_event("处理了1000条记录")
log_event("发生错误: 数据库连接超时", level="ERROR")
log_event("程序关闭")

# app.log文件内容:
# [2024-01-15 10:30:00] [INFO] 程序启动
# [2024-01-15 10:30:02] [INFO] 用户登录: 张三
# [2024-01-15 10:30:03] [INFO] 数据库连接成功
# ...
```

#### 3. 数据存储 - 保存用户数据

任何需要保存用户数据的程序都离不开文件操作:

```python
# 保存用户信息
users = [
    {"username": "zhangsan", "email": "zhang@example.com", "age": 25},
    {"username": "lisi", "email": "li@example.com", "age": 30},
]

# 保存到文件
with open("users.txt", "w", encoding="utf-8") as f:
    for user in users:
        line = f"{user['username']},{user['email']},{user['age']}\n"
        f.write(line)
```

实际应用:
- **记账软件**: 保存你的收支记录
- **待办事项**: 保存你的任务列表
- **笔记软件**: 保存你的笔记内容
- **通讯录**: 保存联系人信息

#### 4. 数据交换 - 与其他程序共享数据

文件是不同程序之间交换数据的常用方式:

```python
# 程序A: 导出数据到CSV文件
import csv

data = [
    ["姓名", "年龄", "城市"],
    ["张三", "25", "北京"],
    ["李四", "30", "上海"],
]

with open("export.csv", "w", encoding="utf-8", newline="") as f:
    writer = csv.writer(f)
    writer.writerows(data)

print("数据已导出到 export.csv")

# 程序B 或 Excel 可以读取这个CSV文件
```

常见的数据交换格式:
- **CSV**: 表格数据(Excel可以打开)
- **JSON**: 结构化数据(几乎所有编程语言都支持)
- **XML**: 复杂的层次化数据
- **TXT**: 纯文本数据

#### 5. 备份恢复 - 数据安全的保障

专业的软件都有备份功能,就是通过文件操作实现的:

```python
from datetime import datetime
import shutil

def backup_data():
    """备份重要数据"""
    # 生成带时间戳的备份文件名
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    backup_filename = f"backup_{timestamp}.txt"

    # 复制原文件
    shutil.copy("important_data.txt", backup_filename)
    print(f"备份成功: {backup_filename}")

# 每天自动备份
backup_data()
```

### 内存 vs 硬盘 - 深入理解数据持久化

让我们用一个更形象的比喻来理解:

**内存(RAM)** = 你的工作桌面
- ✅ 优点: 速度超快,拿取东西很方便
- ❌ 缺点: 收工后东西就被清理了(断电就没了)
- 容量: 相对较小(几GB到几十GB)
- 速度: 非常快(纳秒级)

**硬盘(SSD/HDD)** = 你的文件柜
- ✅ 优点: 长期保存,即使断电也不会丢失
- ❌ 缺点: 读取比内存慢一些
- 容量: 很大(几百GB到几TB)
- 速度: 比内存慢(微秒到毫秒级)

```python
# 这就是为什么程序的运行流程通常是:

# 1. 程序启动时,从硬盘读取数据到内存
with open("data.txt", "r") as f:
    data = f.read()  # 从硬盘加载到内存

# 2. 在内存中快速处理数据
processed_data = data.upper()  # 内存中的操作,超快!

# 3. 需要保存时,从内存写回硬盘
with open("result.txt", "w") as f:
    f.write(processed_data)  # 保存到硬盘,持久化!
```

### 文件操作的基本流程 - 三步走

无论你要做什么文件操作,基本流程都是三步:

```python
# 1. 打开文件(Open)
file = open("myfile.txt", "r")

# 2. 操作文件(Read/Write)
content = file.read()  # 读取
# 或者
# file.write("内容")   # 写入

# 3. 关闭文件(Close)
file.close()  # 非常重要!
```

**为什么必须关闭文件?**

想象你打开了一个文档正在编辑,如果不关闭:
1. 其他程序可能无法访问这个文件
2. 你的修改可能没有真正保存到硬盘
3. 占用系统资源(打开的文件越多,系统越慢)
4. 可能导致数据损坏

这就像借书,用完必须还回去,否则别人就借不到了!

但是手动关闭文件很容易忘记,而且如果程序出错,`close()`可能不会执行。所以Python提供了更好的方式:**with语句**,会自动关闭文件!

```python
# ✅ 推荐: 使用with语句,自动关闭文件
with open("myfile.txt", "r") as file:
    content = file.read()
    # 对文件进行各种操作
# 离开with块后,文件自动关闭!即使发生错误也会关闭!
```

这就像自动门,你走过去门自动打开,走出去门自动关闭,不用担心忘记关门!

## 打开文件 - 第一步

打开文件就像打开一扇门,你需要告诉Python:
1. **打开哪个文件?** (文件名)
2. **怎么打开?** (读/写/追加等模式)
3. **用什么方式解读内容?** (编码方式)

### 基本语法 - 理解每个参数

```python
file = open(filename, mode, encoding)
```

让我们逐个理解这些参数:

#### 1. filename - 文件名或路径

可以是简单的文件名,也可以是完整路径:

```python
# 简单文件名 - 在当前目录查找
file = open("data.txt", "r")

# 相对路径 - 相对于当前目录
file = open("documents/data.txt", "r")
file = open("../data.txt", "r")  # 上一级目录

# 绝对路径 - 完整的文件路径
file = open("C:/Users/YourName/Documents/data.txt", "r")  # Windows
file = open("/home/username/data.txt", "r")  # Linux/Mac
```

**什么是当前目录?**

当前目录就是你运行Python程序时所在的文件夹。比如你在`C:\Projects\MyApp`文件夹中运行`python main.py`,那么当前目录就是`C:\Projects\MyApp`。

```python
import os

# 查看当前目录
print(os.getcwd())  # 获取当前工作目录
# 可能输出: C:\Projects\MyApp

# 所以下面这行会在当前目录查找data.txt
with open("data.txt", "r") as f:
    content = f.read()
```

#### 2. mode - 文件模式(怎么打开文件)

这是最重要的参数,决定了你能对文件做什么操作。就像进房间,你可以:
- 只看不动(只读)
- 可以乱涂乱画(写入)
- 在原有内容后面添加(追加)

让我们详细了解每种模式:

##### 'r' - 只读模式(Read)

```python
# 'r' 模式: 只能读取,不能写入
with open("book.txt", "r") as f:
    content = f.read()  # ✅ 可以读取
    # f.write("新内容")  # ❌ 报错!只读模式不能写入

# 注意: 文件必须存在,否则报错
with open("不存在的文件.txt", "r") as f:  # ❌ FileNotFoundError
    pass
```

**使用场景**:
- 读取配置文件
- 读取日志文件
- 读取数据文件进行分析
- 任何只需要读取不需要修改的情况

##### 'w' - 写入模式(Write)

```python
# 'w' 模式: 写入文件
with open("output.txt", "w") as f:
    f.write("这是新内容")  # ✅ 可以写入
    # content = f.read()   # ❌ 报错!写入模式不能读取

# ⚠️ 危险: 'w' 模式会清空原文件内容!
with open("重要文件.txt", "w") as f:
    f.write("新内容")
# 原来的内容全部丢失!

# 如果文件不存在,会自动创建
with open("新文件.txt", "w") as f:  # ✅ 会创建新文件
    f.write("内容")
```

**使用场景**:
- 创建新文件
- 需要完全覆盖原文件内容
- 导出数据到新文件

**注意**: 使用'w'模式前,一定要确认不需要原文件内容,否则会造成数据丢失!

##### 'a' - 追加模式(Append)

```python
# 'a' 模式: 在文件末尾追加内容
with open("log.txt", "a") as f:
    f.write("新的一行\n")  # ✅ 添加到文件末尾
    f.write("又一行\n")

# ✅ 安全: 'a' 模式不会删除原内容,只会在末尾添加
# 如果文件不存在,会自动创建

# 实际例子: 记录日志
with open("app.log", "a") as f:
    f.write("[2024-01-15 10:30:00] 用户登录\n")
    f.write("[2024-01-15 10:30:05] 查询数据\n")
# 每次运行都会在文件末尾添加新日志,不会覆盖之前的日志
```

**使用场景**:
- 写日志文件
- 添加新记录到数据文件
- 任何需要保留原内容并添加新内容的情况

##### 'x' - 独占创建模式

```python
# 'x' 模式: 创建新文件,如果文件已存在则报错
with open("newfile.txt", "x") as f:  # ✅ 文件不存在,创建成功
    f.write("内容")

with open("newfile.txt", "x") as f:  # ❌ FileExistsError 文件已存在
    f.write("内容")
```

**使用场景**:
- 需要确保文件是新创建的,不会覆盖现有文件
- 防止意外覆盖重要文件

##### 读写模式 - 同时读和写

```python
# 'r+' 模式: 可读可写,文件必须存在
with open("data.txt", "r+") as f:
    content = f.read()     # ✅ 可以读取
    f.write("追加内容")    # ✅ 可以写入

# 'w+' 模式: 可读可写,会清空原文件
with open("data.txt", "w+") as f:
    f.write("新内容")      # 先写入
    f.seek(0)              # 回到文件开头
    content = f.read()     # 再读取

# 'a+' 模式: 可读可写,追加模式
with open("log.txt", "a+") as f:
    f.write("新日志\n")    # 追加写入
    f.seek(0)              # 回到开头
    all_logs = f.read()    # 读取所有日志
```

**注意**: 读写模式用得比较少,因为通常我们会分开读和写操作,更清晰安全。

##### 二进制模式 - 处理非文本文件

```python
# 在任何模式后面加 'b' 就是二进制模式
'rb'   # 二进制读取
'wb'   # 二进制写入
'ab'   # 二进制追加
'rb+'  # 二进制读写

# 处理图片
with open("photo.jpg", "rb") as f:
    image_data = f.read()  # 读取图片的二进制数据
    print(type(image_data))  # <class 'bytes'>

# 复制图片
with open("photo.jpg", "rb") as src:
    with open("photo_copy.jpg", "wb") as dst:
        dst.write(src.read())  # 完美复制!

# 处理其他二进制文件
with open("song.mp3", "rb") as f:  # 音频文件
    audio_data = f.read()

with open("video.mp4", "rb") as f:  # 视频文件
    video_data = f.read()

with open("program.exe", "rb") as f:  # 可执行文件
    exe_data = f.read()
```

**什么时候用二进制模式?**

- ✅ 图片文件(.jpg, .png, .gif, ...)
- ✅ 音频文件(.mp3, .wav, ...)
- ✅ 视频文件(.mp4, .avi, ...)
- ✅ 压缩文件(.zip, .rar, ...)
- ✅ 可执行文件(.exe, .dll, ...)
- ❌ 文本文件(.txt, .py, .html, ...) - 使用文本模式

**文本模式 vs 二进制模式的区别**:

```python
# 文本模式 - 读取的是字符串(str)
with open("text.txt", "r") as f:
    data = f.read()
    print(type(data))  # <class 'str'>
    print(data)        # "Hello World"

# 二进制模式 - 读取的是字节(bytes)
with open("text.txt", "rb") as f:
    data = f.read()
    print(type(data))  # <class 'bytes'>
    print(data)        # b'Hello World'
```

#### 3. encoding - 编码方式(如何解读文件内容)

**什么是编码?**

计算机只能理解0和1(二进制),但我们要存储的是文字。编码就是一套规则,规定了"文字"和"二进制数字"之间的对应关系。

打个比方:编码就像摩尔斯电码。同样是"滴滴哒哒",用不同的解码规则,可能解读出不同的文字。

```python
# 常见的编码方式:

# UTF-8 - 最常用,支持全世界所有文字
with open("file.txt", "r", encoding="utf-8") as f:
    content = f.read()

# GBK - 中文编码(主要用于Windows中文系统)
with open("file.txt", "r", encoding="gbk") as f:
    content = f.read()

# ASCII - 只支持英文
with open("file.txt", "r", encoding="ascii") as f:
    content = f.read()

# Latin-1 - 西欧语言
with open("file.txt", "r", encoding="latin-1") as f:
    content = f.read()
```

**编码不匹配会怎样?** - 乱码!

```python
# 文件是用UTF-8编码保存的,包含中文"你好"
# 但你用GBK解码:
with open("file.txt", "r", encoding="gbk") as f:
    content = f.read()
    print(content)  # 输出: 浣犲ソ (乱码!)

# 正确的做法:
with open("file.txt", "r", encoding="utf-8") as f:
    content = f.read()
    print(content)  # 输出: 你好 (正确!)
```

**推荐做法**:

```python
# ✅ 始终明确指定encoding="utf-8"
with open("file.txt", "r", encoding="utf-8") as f:
    content = f.read()

with open("file.txt", "w", encoding="utf-8") as f:
    f.write("你好世界")

# 为什么? 因为:
# 1. UTF-8是国际标准,支持所有语言
# 2. 大部分现代系统都使用UTF-8
# 3. 避免在不同系统间移动文件时出现乱码
# 4. 特别是处理中文时,UTF-8是最佳选择
```

**常见的编码问题和解决方法**:

```python
# 问题1: 不知道文件是什么编码
# 解决: 依次尝试常见编码
def read_with_fallback(filename):
    """尝试不同编码读取文件"""
    encodings = ['utf-8', 'gbk', 'latin-1']

    for encoding in encodings:
        try:
            with open(filename, 'r', encoding=encoding) as f:
                return f.read()
        except UnicodeDecodeError:
            continue

    # 所有编码都失败了
    raise Exception("无法解码文件")

# 问题2: Windows上的中文文件
# 解决: 可能需要使用gbk编码
try:
    with open("中文.txt", "r", encoding="utf-8") as f:
        content = f.read()
except UnicodeDecodeError:
    # UTF-8失败,尝试GBK
    with open("中文.txt", "r", encoding="gbk") as f:
        content = f.read()
```

### 使用with语句 - 推荐的方式

前面我们说过,文件操作有三步:打开、操作、关闭。手动管理容易出错:

```python
# ❌ 手动管理 - 容易出错
file = open("data.txt", "r")
try:
    content = file.read()
    # 处理content...

    # 如果这里发生错误,file.close()不会执行!
    result = process(content)  # 假设这里抛出异常

finally:
    file.close()  # 必须用try-finally确保文件关闭
```

使用`with`语句,一切都自动化了:

```python
# ✅ 使用with - 简单又安全
with open("data.txt", "r", encoding="utf-8") as file:
    content = file.read()
    result = process(content)
    # 即使process()抛出异常,文件也会自动关闭!
# 离开with块后,文件自动关闭
```

**with语句的魔法是什么?**

`with`语句利用了Python的"上下文管理器"机制:
- **进入with块**: 自动调用`__enter__()`,打开文件
- **离开with块**: 自动调用`__exit__()`,关闭文件(即使发生异常)

```python
# with语句等价于:
file = open("data.txt", "r")
try:
    content = file.read()
    # 你的代码...
finally:
    file.close()

# 但with语句更简洁、更安全、更Pythonic!
```

**with语句的更多用法**:

```python
# 同时打开多个文件
with open("input.txt", "r") as input_file, \
     open("output.txt", "w") as output_file:
    content = input_file.read()
    output_file.write(content.upper())
# 两个文件都会自动关闭

# 嵌套with语句
with open("file1.txt", "r") as f1:
    with open("file2.txt", "r") as f2:
        data1 = f1.read()
        data2 = f2.read()
# 两个文件都会自动关闭

# 或者更简洁的写法
with open("file1.txt", "r") as f1, \
     open("file2.txt", "r") as f2:
    data1 = f1.read()
    data2 = f2.read()
```

### 文件模式速查表

为了方便查阅,这里整理一个文件模式速查表:

| 模式 | 描述 | 文件存在 | 文件不存在 | 读 | 写 | 清空原内容 |
|------|------|----------|------------|-----|-----|------------|
| 'r' | 只读 | ✅ | ❌报错 | ✅ | ❌ | ❌ |
| 'w' | 只写 | ✅ | ✅创建 | ❌ | ✅ | ✅ |
| 'a' | 追加 | ✅ | ✅创建 | ❌ | ✅ | ❌ |
| 'x' | 独占创建 | ❌报错 | ✅创建 | ❌ | ✅ | - |
| 'r+' | 读写 | ✅ | ❌报错 | ✅ | ✅ | ❌ |
| 'w+' | 读写 | ✅ | ✅创建 | ✅ | ✅ | ✅ |
| 'a+' | 读写追加 | ✅ | ✅创建 | ✅ | ✅ | ❌ |

加上'b'就是二进制模式:'rb', 'wb', 'ab', 'rb+', 'wb+', 'ab+'

**选择文件模式的决策树**:

```
要读取文件吗?
├─ 是 → 文件必须存在吗?
│        ├─ 是 → 用 'r'
│        └─ 否 → 也需要写入吗?
│                 ├─ 是 → 用 'a+' 或 'w+'
│                 └─ 否 → 用 'r'
│
└─ 否 → 要保留原内容吗?
         ├─ 是 → 用 'a'(追加到末尾)
         └─ 否 → 用 'w'(覆盖原内容)
```

### 实际例子: 不同场景选择不同模式

```python
# 场景1: 读取配置文件
# 选择: 'r' (只读,文件必须存在)
with open("config.ini", "r", encoding="utf-8") as f:
    config = f.read()

# 场景2: 写入日志
# 选择: 'a' (追加,保留旧日志)
with open("app.log", "a", encoding="utf-8") as f:
    f.write("[2024-01-15] 新日志\n")

# 场景3: 导出数据
# 选择: 'w' (覆盖,生成新文件)
with open("export.txt", "w", encoding="utf-8") as f:
    f.write("导出的数据")

# 场景4: 复制图片
# 选择: 'rb' 和 'wb' (二进制模式)
with open("原图.jpg", "rb") as src:
    with open("副本.jpg", "wb") as dst:
        dst.write(src.read())

# 场景5: 安全创建文件,不覆盖现有文件
# 选择: 'x' (独占创建)
try:
    with open("report.txt", "x", encoding="utf-8") as f:
        f.write("报告内容")
except FileExistsError:
    print("文件已存在,不能覆盖!")
```

## 读取文件 - 获取文件内容

文件打开后,下一步就是读取里面的内容。Python提供了多种读取方式,就像吃东西可以"一口全吃掉"、"一勺一勺吃"、"一口一口慢慢吃"一样。

### 读取方式概览

在详细学习之前,先看看所有的读取方式:

```python
with open("file.txt", "r") as f:
    # 方法1: read() - 一次读取全部内容
    content = f.read()

    # 方法2: readline() - 读取一行
    line = f.readline()

    # 方法3: readlines() - 读取所有行,返回列表
    lines = f.readlines()

    # 方法4: 迭代文件对象 - 逐行读取(推荐)
    for line in f:
        print(line)
```

不同的读取方式适用于不同的场景,让我们逐个深入了解。

### 方法1: read() - 一次读取全部内容

`read()`方法就像把整本书一口气读完,一次性把文件的所有内容加载到内存中。

```python
# 读取整个文件
with open("book.txt", "r", encoding="utf-8") as f:
    content = f.read()  # 返回字符串,包含文件的所有内容
    print(type(content))  # <class 'str'>
    print(len(content))   # 字符串长度
    print(content)
```

**read()的参数 - 读取指定字符数**:

```python
with open("file.txt", "r", encoding="utf-8") as f:
    # 读取前10个字符
    first_10 = f.read(10)
    print(first_10)

    # 再读取接下来的5个字符
    next_5 = f.read(5)
    print(next_5)

    # 读取剩余所有内容
    rest = f.read()
    print(rest)
```

**read()的优点**:
- ✅ 简单直接,一行代码搞定
- ✅ 适合小文件
- ✅ 读取后可以方便地进行字符串操作

**read()的缺点**:
- ❌ 大文件会占用大量内存
- ❌ 读取大文件速度慢
- ❌ 如果文件太大,可能导致内存不足

**什么时候用read()?**

```python
# ✅ 适合: 小文件(几KB到几MB)
with open("config.txt", "r") as f:  # 配置文件通常很小
    config = f.read()

with open("poem.txt", "r") as f:  # 一首诗不会太长
    poem = f.read()

# ❌ 不适合: 大文件(几百MB或GB)
with open("huge_log.txt", "r") as f:  # 可能有几GB!
    content = f.read()  # 危险!可能导致内存不足
```

**实际例子**: 读取并处理小文件

```python
# 读取HTML文件
with open("index.html", "r", encoding="utf-8") as f:
    html = f.read()

    # 查找关键词
    if "Python" in html:
        print("页面包含Python关键词")

    # 替换内容
    html = html.replace("旧标题", "新标题")

    # 统计标签数量
    h1_count = html.count("<h1>")
    print(f"H1标签数量: {h1_count}")

# 读取JSON配置文件
import json

with open("settings.json", "r", encoding="utf-8") as f:
    json_text = f.read()
    settings = json.loads(json_text)
    print(settings["theme"])  # 获取配置项
```

### 方法2: readline() - 逐行读取

`readline()`方法就像一行一行地读书,每次读取一行内容。

```python
with open("file.txt", "r", encoding="utf-8") as f:
    # 读取第一行
    line1 = f.readline()
    print("第一行:", line1)

    # 读取第二行
    line2 = f.readline()
    print("第二行:", line2)

    # 读取第三行
    line3 = f.readline()
    print("第三行:", line3)

    # 如果读到文件末尾,返回空字符串""
    line4 = f.readline()
    if line4 == "":
        print("已到文件末尾")
```

**注意**: `readline()`返回的字符串包含行尾的换行符`\n`:

```python
# 假设file.txt内容:
# Hello
# World

with open("file.txt", "r") as f:
    line1 = f.readline()
    print(repr(line1))  # 'Hello\n' (包含换行符)

    # 去除换行符
    line1_clean = line1.strip()  # 或 line1.rstrip('\n')
    print(repr(line1_clean))  # 'Hello'
```

**使用while循环逐行读取整个文件**:

```python
with open("file.txt", "r", encoding="utf-8") as f:
    while True:
        line = f.readline()

        # 如果读到空字符串,说明文件结束
        if not line:  # 或 if line == ""
            break

        # 处理这一行
        print(line.strip())
```

**readline()的优点**:
- ✅ 内存占用小(每次只读一行)
- ✅ 适合大文件
- ✅ 可以在读取过程中做决策(比如找到目标行就停止)

**readline()的缺点**:
- ❌ 代码相对繁琐(需要循环)
- ❌ 不如迭代文件对象简洁

**实际例子**: 查找特定行

```python
# 在日志文件中查找第一个ERROR
with open("app.log", "r") as f:
    line_number = 0
    while True:
        line = f.readline()
        if not line:
            print("未找到ERROR")
            break

        line_number += 1
        if "ERROR" in line:
            print(f"在第{line_number}行找到ERROR:")
            print(line.strip())
            break

# 读取CSV文件的表头
with open("data.csv", "r") as f:
    header = f.readline().strip()  # 第一行是表头
    columns = header.split(",")
    print(f"表格有{len(columns)}列:", columns)

    # 然后可以逐行读取数据
    while True:
        line = f.readline()
        if not line:
            break
        # 处理数据行...
```

### 方法3: readlines() - 读取所有行到列表

`readlines()`一次性读取所有行,返回一个列表,每个元素是一行:

```python
with open("file.txt", "r", encoding="utf-8") as f:
    lines = f.readlines()
    print(type(lines))  # <class 'list'>
    print(len(lines))   # 文件有多少行

    # 访问特定行
    print(lines[0])     # 第一行
    print(lines[1])     # 第二行
    print(lines[-1])    # 最后一行
```

**假设file.txt内容**:
```
第一行
第二行
第三行
```

**readlines()的结果**:
```python
lines = ['第一行\n', '第二行\n', '第三行\n']
```

**处理readlines()的结果**:

```python
with open("file.txt", "r") as f:
    lines = f.readlines()

    # 方法1: 使用for循环
    for line in lines:
        print(line.strip())  # 去除换行符

    # 方法2: 使用列表推导式
    clean_lines = [line.strip() for line in lines]
    print(clean_lines)  # ['第一行', '第二行', '第三行']

    # 方法3: 访问特定行
    if len(lines) > 5:
        sixth_line = lines[5].strip()
        print(f"第六行: {sixth_line}")
```

**readlines()的优点**:
- ✅ 可以多次访问所有行
- ✅ 可以用索引访问特定行
- ✅ 可以方便地知道文件有多少行
- ✅ 适合需要随机访问行的场景

**readlines()的缺点**:
- ❌ 一次性加载所有内容到内存(像read()一样)
- ❌ 大文件会占用大量内存
- ❌ 返回的列表包含换行符,需要额外处理

**实际例子**: 处理需要多次访问的小文件

```python
# 例子1: 统计特定行
with open("scores.txt", "r") as f:
    lines = f.readlines()

    # 第一次遍历: 找最高分
    max_score = 0
    for line in lines:
        score = int(line.strip())
        if score > max_score:
            max_score = score

    # 第二次遍历: 统计及格人数
    passed = sum(1 for line in lines if int(line.strip()) >= 60)

    print(f"最高分: {max_score}")
    print(f"及格人数: {passed}")

# 例子2: 反转文件内容
with open("input.txt", "r") as f:
    lines = f.readlines()

# 反转顺序
reversed_lines = lines[::-1]

# 写入新文件
with open("output.txt", "w") as f:
    f.writelines(reversed_lines)

# 例子3: 跳过表头读取数据
with open("data.csv", "r") as f:
    lines = f.readlines()

    header = lines[0].strip()  # 第一行是表头
    data_lines = lines[1:]      # 从第二行开始是数据

    for line in data_lines:
        # 处理数据...
        pass
```

### 方法4: 迭代文件对象 - 最Pythonic的方式(推荐)

直接迭代文件对象,是最简洁、最高效、最Pythonic的方式:

```python
# ✅ 最推荐的方式
with open("file.txt", "r", encoding="utf-8") as f:
    for line in f:
        print(line.strip())
```

就这么简单!不需要调用任何方法,文件对象本身就是可迭代的。

**为什么这种方式最好?**

1. **代码简洁**: 不需要显式调用`readline()`或`readlines()`
2. **内存高效**: 逐行读取,不会一次性加载整个文件
3. **性能好**: 内部优化,读取速度快
4. **Pythonic**: 符合Python的设计哲学

**对比所有方式**:

```python
# 假设file.txt内容:
# 第一行
# 第二行
# 第三行

# 方式1: read() - 读取全部
with open("file.txt", "r") as f:
    content = f.read()
    print(repr(content))  # '第一行\n第二行\n第三行\n'

# 方式2: readlines() - 返回列表
with open("file.txt", "r") as f:
    lines = f.readlines()
    print(lines)  # ['第一行\n', '第二行\n', '第三行\n']
    for line in lines:
        print(line.strip())

# 方式3: 迭代文件对象 - 最简洁(推荐)
with open("file.txt", "r") as f:
    for line in f:
        print(line.strip())  # 第一行 第二行 第三行
```

**迭代文件对象的高级用法**:

```python
# 1. 带行号遍历
with open("file.txt", "r") as f:
    for line_num, line in enumerate(f, start=1):
        print(f"第{line_num}行: {line.strip()}")

# 2. 处理空行
with open("file.txt", "r") as f:
    for line in f:
        line = line.strip()
        if not line:  # 跳过空行
            continue
        print(line)

# 3. 查找特定内容
with open("file.txt", "r") as f:
    for line in f:
        if "关键词" in line:
            print(f"找到: {line.strip()}")
            break  # 找到后停止

# 4. 过滤和转换
with open("numbers.txt", "r") as f:
    numbers = [int(line.strip()) for line in f if line.strip().isdigit()]
    print(f"读取到{len(numbers)}个数字")
    print(f"总和: {sum(numbers)}")

# 5. 分块处理
with open("huge_file.txt", "r") as f:
    batch = []
    for line in f:
        batch.append(line.strip())
        if len(batch) == 1000:  # 每1000行处理一次
            process_batch(batch)
            batch = []
    if batch:  # 处理剩余的行
        process_batch(batch)
```

**实际例子**: 各种文件处理任务

```python
# 例子1: 日志分析 - 统计错误数量
error_count = 0
with open("app.log", "r") as f:
    for line in f:
        if "ERROR" in line:
            error_count += 1
print(f"共有{error_count}个错误")

# 例子2: 配置文件解析
config = {}
with open("config.ini", "r") as f:
    for line in f:
        line = line.strip()
        if not line or line.startswith("#"):  # 跳过空行和注释
            continue
        if "=" in line:
            key, value = line.split("=", 1)
            config[key.strip()] = value.strip()
print(config)

# 例子3: 数据过滤
with open("input.txt", "r") as fin, \
     open("output.txt", "w") as fout:
    for line in fin:
        # 只保留包含数字的行
        if any(char.isdigit() for char in line):
            fout.write(line)

# 例子4: CSV文件统计
total_sales = 0
with open("sales.csv", "r") as f:
    header = next(f)  # 跳过表头
    for line in f:
        # 假设第三列是销售额
        columns = line.strip().split(",")
        total_sales += float(columns[2])
print(f"总销售额: ¥{total_sales:.2f}")

# 例子5: 查找并替换
with open("input.txt", "r") as fin, \
     open("output.txt", "w") as fout:
    for line in fin:
        # 替换所有"旧词"为"新词"
        line = line.replace("旧词", "新词")
        fout.write(line)
```

### 四种读取方式对比总结

| 方式 | 内存占用 | 适用场景 | 优点 | 缺点 |
|------|----------|----------|------|------|
| `read()` | 高(全部加载) | 小文件 | 简单直接 | 大文件会爆内存 |
| `readline()` | 低(逐行读取) | 需要逐行决策 | 内存友好 | 代码繁琐 |
| `readlines()` | 高(全部加载) | 需要多次访问 | 可用索引访问 | 大文件会爆内存 |
| 迭代文件对象 | 低(逐行读取) | 大多数情况(推荐) | 简洁高效 | 无 |

**选择建议**:

```python
# ✅ 默认选择: 迭代文件对象
with open("file.txt", "r") as f:
    for line in f:
        process(line)

# ✅ 小文件且需要整体处理: read()
with open("small_file.txt", "r") as f:
    content = f.read()
    # 字符串操作...

# ✅ 需要随机访问特定行: readlines()
with open("file.txt", "r") as f:
    lines = f.readlines()
    first_line = lines[0]
    last_line = lines[-1]

# ✅ 需要逐行决策: readline() 或 迭代
with open("file.txt", "r") as f:
    for line in f:
        if "STOP" in line:
            break  # 找到就停止
```

### 读取文件的最佳实践

```python
# 1. 始终指定encoding
with open("file.txt", "r", encoding="utf-8") as f:
    content = f.read()

# 2. 处理大文件用迭代
with open("huge_file.txt", "r", encoding="utf-8") as f:
    for line in f:  # 不要用read()
        process(line)

# 3. 去除换行符
with open("file.txt", "r") as f:
    for line in f:
        line = line.strip()  # 或 rstrip('\n')
        print(line)

# 4. 处理异常
try:
    with open("file.txt", "r") as f:
        content = f.read()
except FileNotFoundError:
    print("文件不存在")
except UnicodeDecodeError:
    print("文件编码错误")

# 5. 跳过空行和注释
with open("file.txt", "r") as f:
    for line in f:
        line = line.strip()
        if not line or line.startswith("#"):
            continue
        # 处理有效行...
```

(继续完善第18章...)
