# 第17章:模块和包

学习如何组织和重用代码,让项目结构更清晰,代码维护更轻松。

## 什么是模块?

想象一下这个场景:你写了一个超级好用的计算税费的函数,非常精准,考虑了各种情况。现在你要开发5个不同的项目,每个项目都需要用到这个计算税费的功能。怎么办?难道每次都要复制粘贴这段代码吗?如果发现计算逻辑有bug要修改,难道要改5个地方吗?

这就是模块(Module)要解决的问题!**模块就是一个包含可重用代码的.py文件**,里面可以有函数、类、变量等。把常用的代码写成模块,就像把工具放进工具箱,随时取用,方便又高效。

### 模块到底是什么?

说白了,**模块就是一个普通的Python文件**(.py文件)。没错,就这么简单!你之前写的每个.py文件其实都可以作为模块被别的程序导入使用。

比如你有一个文件叫`calculator.py`,里面写了一些计算函数:

```python
# calculator.py
def add(a, b):
    return a + b

def subtract(a, b):
    return a - b
```

这个`calculator.py`文件就是一个模块!其他程序可以导入它,使用里面的函数。

### 为什么需要模块?一个真实的例子

假设你在开发一个电商网站,需要处理订单、库存、用户等各种功能。如果把所有代码都写在一个文件里,那这个文件会有几千行甚至上万行代码,维护起来简直是噩梦!

```python
# 不使用模块 - 所有代码挤在一个文件里
# ecommerce.py (假设有5000行代码)

# 订单相关代码 (500行)
def create_order(...):
    pass
def cancel_order(...):
    pass
# ... 更多订单函数

# 库存相关代码 (500行)
def check_stock(...):
    pass
def update_stock(...):
    pass
# ... 更多库存函数

# 用户相关代码 (500行)
def register_user(...):
    pass
def login_user(...):
    pass
# ... 更多用户函数

# ... 还有支付、物流、评论等等
```

这样的代码结构有什么问题?

1. **难以查找** - 想找个函数要翻半天
2. **容易冲突** - 可能不小心定义了两个同名函数
3. **难以协作** - 多人同时修改同一个文件,冲突不断
4. **难以测试** - 测试某个功能要运行整个文件
5. **难以维护** - 改一个地方可能影响其他地方

使用模块后,代码结构变得清晰多了:

```
ecommerce/
├── orders.py      # 订单相关模块
├── inventory.py   # 库存相关模块
├── users.py       # 用户相关模块
├── payments.py    # 支付相关模块
└── shipping.py    # 物流相关模块
```

每个模块只负责一个功能领域,各司其职,清晰明了!

### 模块的好处 - 为什么要学它?

让我们用更具体的例子来说明模块的各种好处:

#### 1. 代码重用 - 写一次,到处用

想象你写了一个验证邮箱格式的函数,非常完善:

```python
# email_utils.py
def validate_email(email):
    """验证邮箱格式是否正确"""
    if "@" not in email:
        return False
    if "." not in email.split("@")[1]:
        return False
    # ... 更多验证逻辑
    return True
```

有了这个模块,你的所有项目都可以用它:

```python
# 项目1: 用户注册系统
from email_utils import validate_email
if validate_email(user_email):
    register_user(user_email)

# 项目2: 邮件营销系统
from email_utils import validate_email
valid_emails = [e for e in emails if validate_email(e)]

# 项目3: 客户管理系统
from email_utils import validate_email
customer.email_valid = validate_email(customer.email)
```

一次编写,到处复用,省时省力!

#### 2. 避免重复 - 告别复制粘贴

以前没有模块的时候,程序员经常要做这种事:

```python
# 文件1
def calculate_tax(price):
    return price * 0.13  # 复制粘贴

# 文件2
def calculate_tax(price):
    return price * 0.13  # 复制粘贴

# 文件3
def calculate_tax(price):
    return price * 0.13  # 复制粘贴
```

如果税率改成0.15怎么办?要改3个地方!万一漏改了一个,就会出bug。

有了模块:

```python
# tax_utils.py (模块)
def calculate_tax(price):
    return price * 0.13  # 只写一次

# 其他文件都导入这个模块
from tax_utils import calculate_tax
```

税率要改?只需要改模块里的一个地方,所有使用它的代码都会自动更新!

#### 3. 组织代码 - 让项目结构清晰

就像整理房间一样,把东西分门别类放好,找起来就方便:

```
杂乱的房间 (没有模块):
所有东西都堆在一起,找个东西要翻半天

整洁的房间 (使用模块):
├── 书架/ (books.py)
├── 衣柜/ (clothes.py)
├── 抽屉/ (accessories.py)
└── 工具箱/ (tools.py)
```

代码也一样:

```
杂乱的项目:
main.py (所有代码5000行)

清晰的项目:
├── database.py     (数据库操作)
├── api.py          (API接口)
├── validators.py   (数据验证)
├── utils.py        (工具函数)
└── config.py       (配置信息)
```

#### 4. 命名空间 - 避免函数名冲突

想象一下,两个人都写了一个叫`send()`的函数:

```python
# 小张写的发送邮件函数
def send(email, content):
    # 发送邮件的逻辑
    pass

# 小李写的发送短信函数
def send(phone, message):
    # 发送短信的逻辑
    pass
```

如果都在一个文件里,后面的`send`会覆盖前面的!但有了模块:

```python
# email_module.py
def send(email, content):
    pass

# sms_module.py
def send(phone, message):
    pass

# 使用时:
import email_module
import sms_module

email_module.send("user@example.com", "Hello")  # 发邮件
sms_module.send("13800138000", "Hello")         # 发短信
```

通过模块名前缀,两个同名函数互不干扰!

#### 5. 分工合作 - 团队开发更高效

在团队开发中,模块让多人协作变得更容易:

```
项目经理说:
"小张,你负责用户管理模块 (users.py)"
"小李,你负责订单处理模块 (orders.py)"
"小王,你负责支付模块 (payments.py)"
```

每个人在自己的模块里开发,互不干扰。只要定义好模块之间的接口(函数的参数和返回值),就可以并行开发,效率大大提高!

### 模块的本质 - 深入理解

从技术角度来说,**模块就是一个包含Python代码的文件**。当你导入一个模块时,Python解释器会:

1. **找到这个文件** - 在特定的路径中搜索
2. **执行这个文件** - 运行文件中的所有代码
3. **创建一个命名空间** - 把文件中定义的函数、类、变量放入这个空间
4. **返回模块对象** - 让你可以访问模块中的内容

听起来有点复杂?其实很简单,我们通过例子来看:

```python
# mymath.py
print("mymath模块被导入了!")

def add(a, b):
    return a + b

PI = 3.14159
```

当你在另一个文件中导入它:

```python
import mymath  # 这时会打印: mymath模块被导入了!

print(mymath.add(1, 2))  # 使用模块中的函数
print(mymath.PI)          # 使用模块中的变量
```

看到了吗?导入模块时,模块中的代码会被执行一次(所以打印语句会运行),然后你就可以使用模块中定义的所有内容了。

### 模块 vs 脚本 - 有什么区别?

这是很多初学者容易混淆的概念:

**脚本(Script)**:
- 目的是直接运行,完成某个任务
- 通常包含主逻辑代码和`print`语句
- 例如: `download_images.py`用于下载图片

**模块(Module)**:
- 目的是被其他程序导入使用
- 通常只定义函数、类,不直接执行任务
- 例如: `image_utils.py`提供图片处理函数

一个文件既可以是脚本,也可以是模块!这取决于怎么使用它:

```python
# image_utils.py
def resize_image(image, width, height):
    """调整图片大小"""
    # 图片处理逻辑
    pass

# 作为模块使用时:
from image_utils import resize_image
resize_image(my_image, 800, 600)

# 作为脚本使用时:
python image_utils.py  # 直接运行这个文件
```

稍后我们会学习`if __name__ == "__main__"`,它可以让一个文件既能当模块用,又能当脚本用,非常实用!

## 导入模块的方式

Python提供了多种导入模块的方法,就像去商店买东西有不同的方式一样。你可以把整个货架都搬回家(导入整个模块),也可以只挑几样需要的商品(导入特定函数),还可以给商品起个昵称(使用别名)。让我们详细了解每种方式的用法和场景。

### 导入方式概览 - 先看全景

在详细学习之前,先看看所有的导入方式:

```python
# 方式1: 导入整个模块
import math

# 方式2: 导入特定内容
from math import pi, sqrt

# 方式3: 导入所有内容(不推荐)
from math import *

# 方式4: 使用别名
import numpy as np
from math import sqrt as square_root

# 方式5: 导入子模块
from os import path
import os.path
```

每种方式都有自己的适用场景,选对方式可以让代码更清晰、更易维护。

### 方式1: import 模块名 - 最正规的导入方式

这是最常见、最推荐的导入方式。就像去图书馆借书,你借了一整本书回来:

```python
# 导入整个模块
import math

# 使用时需要加模块名前缀
print(math.pi)        # 3.141592653589793
print(math.sqrt(16))  # 4.0
print(math.pow(2, 3)) # 8.0
```

**这种方式的特点:**

1. **清晰明了** - 一眼就能看出函数来自哪个模块
   ```python
   result1 = math.sqrt(16)      # 清楚是数学库的平方根
   result2 = cmath.sqrt(-1)     # 清楚是复数数学库的平方根
   ```

2. **避免命名冲突** - 不同模块的同名函数不会互相覆盖
   ```python
   import os
   import sys

   # 两个模块都有path,但不会冲突
   print(os.path)   # os模块的path
   print(sys.path)  # sys模块的path
   ```

3. **代码可读性好** - 看代码时知道每个函数的来源
   ```python
   # 一看就知道这是日期时间相关的操作
   import datetime
   now = datetime.datetime.now()
   tomorrow = now + datetime.timedelta(days=1)
   ```

**实际应用场景:**

```python
# 场景1: 科学计算
import math
import statistics

def calculate_metrics(numbers):
    """计算数据的各种指标"""
    avg = statistics.mean(numbers)           # 平均值
    std = statistics.stdev(numbers)          # 标准差
    sqrt_sum = math.sqrt(sum(numbers))       # 和的平方根
    return avg, std, sqrt_sum

# 场景2: 文件操作
import os
import shutil

def backup_files(source_dir, backup_dir):
    """备份文件"""
    if os.path.exists(source_dir):
        shutil.copytree(source_dir, backup_dir)
        print(f"备份完成: {os.path.getsize(backup_dir)} 字节")
```

**什么时候用这种方式?**

- ✅ 当模块名简短时: `import os`, `import sys`, `import json`
- ✅ 当需要使用模块中多个函数时
- ✅ 当想让代码更清晰时
- ✅ 当有命名冲突风险时

### 方式2: from 模块名 import 函数名 - 按需导入

这种方式就像去超市只买需要的东西,不用把整个超市搬回家:

```python
# 只导入需要的函数
from math import pi, sqrt, pow

# 使用时不需要模块名前缀
print(pi)        # 3.141592653589793
print(sqrt(16))  # 4.0
print(pow(2, 3)) # 8.0
```

**这种方式的好处:**

1. **代码更简洁** - 不用每次都写模块名
   ```python
   # 对比一下:

   # 使用 import math
   import math
   result = math.sqrt(math.pow(math.pi, 2))  # 写了三次math

   # 使用 from import
   from math import sqrt, pow, pi
   result = sqrt(pow(pi, 2))  # 简洁多了
   ```

2. **提高可读性** - 对于常用函数特别方便
   ```python
   from datetime import datetime, timedelta

   now = datetime.now()                    # 而不是 datetime.datetime.now()
   tomorrow = now + timedelta(days=1)      # 而不是 datetime.timedelta(days=1)
   ```

**实际应用场景:**

```python
# 场景1: 只用几个函数时
from random import randint, choice

def roll_dice():
    """掷骰子"""
    return randint(1, 6)

def pick_winner(names):
    """随机选择赢家"""
    return choice(names)

# 场景2: 频繁使用某些函数
from math import sqrt, pi

def calculate_circle_area(radius):
    """计算圆的面积"""
    return pi * sqrt(radius) ** 2  # 代码更简洁

# 场景3: 导入类
from datetime import datetime, date, time

def create_timestamp():
    """创建时间戳"""
    now = datetime.now()
    today = date.today()
    current_time = time(12, 30, 0)
    return now, today, current_time
```

**可以导入多个内容:**

```python
# 从一个模块导入多个函数
from math import (
    sqrt,      # 平方根
    pi,        # 圆周率
    e,         # 自然常数
    ceil,      # 向上取整
    floor,     # 向下取整
    factorial  # 阶乘
)

# 使用时很方便
print(sqrt(16))        # 4.0
print(pi)              # 3.14159...
print(factorial(5))    # 120
```

**注意事项:**

虽然这种方式很方便,但也要小心使用:

```python
# ❌ 问题: 可能不清楚函数来自哪里
from math import sqrt
from numpy import sqrt  # 覆盖了math的sqrt!

result = sqrt(16)  # 用的是哪个sqrt?不清楚!

# ✅ 解决: 使用别名
from math import sqrt as math_sqrt
from numpy import sqrt as numpy_sqrt

result1 = math_sqrt(16)    # 清楚是math的
result2 = numpy_sqrt(16)   # 清楚是numpy的
```

**什么时候用这种方式?**

- ✅ 只需要模块中的少数几个函数
- ✅ 这些函数会被频繁使用
- ✅ 想让代码更简洁
- ✅ 确定不会有命名冲突

### 方式3: from 模块名 import * - 导入所有(慎用!)

这种方式就像把超市里所有商品都免费拿回家,听起来很棒,但实际上会造成很多问题:

```python
# 导入模块中的所有内容
from math import *

# 可以直接使用所有函数
print(pi)        # 3.141592653589793
print(sqrt(16))  # 4.0
print(sin(0))    # 0.0
print(cos(0))    # 1.0
```

**为什么不推荐使用?**

#### 问题1: 命名空间污染 - 不知道哪些名字被导入了

```python
from math import *

# 这些函数都可以用,但你记得住math里有哪些函数吗?
result1 = sqrt(16)    # 这个记得
result2 = gcd(12, 8)  # 这个呢?
result3 = hypot(3, 4) # 这个呢?
```

过一段时间,你自己都不记得哪些函数是从math导入的了!

#### 问题2: 命名冲突 - 函数会被无声地覆盖

```python
# 致命的问题!
from math import *
from statistics import *

# 两个模块都有mean()函数,后导入的会覆盖前面的
data = [1, 2, 3, 4, 5]
result = mean(data)  # 用的是哪个mean?谁知道!
```

这种bug非常难发现,因为没有任何错误提示,程序就是得到错误的结果!

#### 问题3: 代码可读性差 - 看不出函数来源

```python
from math import *
from random import *
from statistics import *

# 几个月后你回来看自己的代码:
result1 = mean([1, 2, 3])      # 来自statistics?
result2 = sqrt(16)              # 来自math?
result3 = choice([1, 2, 3])     # 来自random?
```

完全不知道这些函数从哪来,维护代码变得很困难!

**唯一可能使用的场景:**

只有在**交互式环境**(比如Jupyter Notebook)中,为了方便实验,才可能使用:

```python
# 在Jupyter Notebook中快速实验
from math import *
from numpy import *

# 方便快速测试各种函数
print(sqrt(16))
print(sin(pi/2))
print(array([1, 2, 3]))
```

但即使在这种情况下,也最好导入特定函数或使用别名!

**总结: 几乎永远不要使用 `from xxx import *`!**

```python
# ❌ 不推荐
from math import *
from os import *

# ✅ 推荐: 明确导入需要的内容
from math import sqrt, pi, sin, cos
from os import path, environ, getcwd

# 或者使用别名
import math as m
import os
```

### 方式4: 使用别名(as) - 让代码更简洁

给模块或函数起别名,就像给朋友起外号一样,方便又亲切:

```python
# 给模块起别名
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# 使用别名,简洁多了
arr = np.array([1, 2, 3])           # 而不是 numpy.array([1, 2, 3])
df = pd.DataFrame({'col': [1, 2]})  # 而不是 pandas.DataFrame(...)
plt.plot([1, 2, 3])                 # 而不是 matplotlib.pyplot.plot(...)
```

**为什么要使用别名?**

#### 原因1: 模块名太长

有些模块名字特别长,每次都写全很麻烦:

```python
# 原始方式 - 太长了!
import matplotlib.pyplot
matplotlib.pyplot.plot([1, 2, 3])
matplotlib.pyplot.xlabel("X轴")
matplotlib.pyplot.ylabel("Y轴")
matplotlib.pyplot.show()

# 使用别名 - 简洁多了!
import matplotlib.pyplot as plt
plt.plot([1, 2, 3])
plt.xlabel("X轴")
plt.ylabel("Y轴")
plt.show()
```

#### 原因2: 遵循社区约定

Python社区对某些常用库有约定俗成的别名,使用这些别名可以让代码更容易被其他人理解:

```python
# 数据科学常用的别名约定
import numpy as np              # NumPy数组库
import pandas as pd             # Pandas数据分析库
import matplotlib.pyplot as plt # Matplotlib绘图库
import seaborn as sns           # Seaborn统计绘图库
import tensorflow as tf         # TensorFlow机器学习库
import torch as T               # PyTorch机器学习库(有人用T,有人用torch)
```

当别人看到`np.array`时,立刻就知道这是NumPy数组;看到`pd.DataFrame`时,立刻知道这是Pandas数据框。

#### 原因3: 避免命名冲突

当模块名和你的变量名冲突时,可以用别名:

```python
# 假设你有一个变量叫json
json = {"name": "张三", "age": 18}

# 这时不能再 import json 了,会冲突!
# 解决方法: 使用别名
import json as JSON

# 现在两者可以共存
data = JSON.dumps(json)  # 用JSON模块处理json变量
```

**给函数起别名:**

不仅模块可以起别名,函数也可以:

```python
# 给函数起别名
from math import sqrt as square_root
from math import pow as power

print(square_root(16))  # 4.0 - 更容易理解的名字
print(power(2, 3))      # 8.0 - 更容易理解的名字

# 实际例子: 让代码更符合你的习惯
from statistics import mean as average
from statistics import stdev as std_deviation

numbers = [1, 2, 3, 4, 5]
print(average(numbers))        # 平均值
print(std_deviation(numbers))  # 标准差
```

**实际应用场景:**

```python
# 场景1: 数据分析
import pandas as pd
import numpy as np

# 读取数据
df = pd.read_csv("data.csv")
# 计算统计量
mean_value = np.mean(df['price'])

# 场景2: 图像处理
from PIL import Image as IMG

# 打开图片
photo = IMG.open("photo.jpg")
# 调整大小
resized = photo.resize((800, 600))

# 场景3: 避免冲突
from datetime import date as Date
from mymodule import date  # 你自己的date函数

today = Date.today()       # 标准库的date
my_date = date("2024-01-15")  # 你的date函数
```

**别名的命名规范:**

```python
# ✅ 好的别名
import numpy as np           # 简短、约定俗成
import pandas as pd          # 简短、约定俗成
from datetime import datetime as dt  # 有意义的缩写

# ❌ 不好的别名
import numpy as n            # 太短,不清楚
import pandas as ppppp       # 无意义
from datetime import datetime as x  # 无意义
```

### 方式5: 导入子模块 - 处理模块层次结构

有些模块是分层组织的,就像文件夹里套文件夹:

```python
# os模块下有很多子模块
import os
import os.path

# 使用os模块
files = os.listdir(".")

# 使用os.path子模块
exists = os.path.exists("test.txt")
size = os.path.getsize("test.txt")
```

**另一种方式: 直接导入子模块**

```python
# 直接导入path子模块
from os import path

# 使用path模块的功能
if path.exists("test.txt"):
    print(f"文件大小: {path.getsize('test.txt')} 字节")
    print(f"文件路径: {path.abspath('test.txt')}")
```

**常见的层次化模块:**

```python
# email模块 - 邮件处理
import email.mime.text
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

# XML处理
import xml.etree.ElementTree
from xml.etree.ElementTree import Element, SubElement

# urllib - 网络请求
import urllib.request
import urllib.parse
from urllib.request import urlopen
from urllib.parse import urlencode

# collections - 数据结构
from collections.abc import Iterable, Mapping
```

**实际例子: 处理JSON文件路径**

```python
import json
from os import path

def load_json_file(filename):
    """加载JSON文件"""
    # 检查文件是否存在
    if not path.exists(filename):
        print(f"文件不存在: {filename}")
        return None

    # 获取完整路径
    full_path = path.abspath(filename)
    print(f"正在读取: {full_path}")

    # 读取JSON
    with open(filename, 'r') as f:
        data = json.load(f)

    return data
```

### 导入方式对比 - 如何选择?

不同情况使用不同的导入方式:

```python
# ✅ 场景1: 需要模块的多个功能 - 导入模块
import math
result = math.sqrt(math.pi ** 2) + math.e

# ✅ 场景2: 只用1-3个函数,会频繁使用 - 导入函数
from math import sqrt, pi
result = sqrt(pi ** 2) + sqrt(16)

# ✅ 场景3: 模块名太长 - 使用别名
import matplotlib.pyplot as plt
plt.plot([1, 2, 3])

# ✅ 场景4: 需要区分不同来源的同名函数 - 使用模块名或别名
import math
import cmath
math_result = math.sqrt(16)   # 实数平方根
cmath_result = cmath.sqrt(-1) # 复数平方根

# ❌ 避免: 导入所有
from math import *  # 不推荐!
```

**一个完整的例子,展示各种导入方式的配合使用:**

```python
# 数据分析脚本
import sys                    # 导入整个模块
from pathlib import Path      # 导入类
import pandas as pd           # 使用别名
import numpy as np            # 使用别名
from datetime import datetime, timedelta  # 导入多个
import matplotlib.pyplot as plt           # 导入子模块+别名

def analyze_data(filename):
    """分析数据文件"""
    # 使用Path检查文件
    file_path = Path(filename)
    if not file_path.exists():
        print(f"文件不存在: {filename}", file=sys.stderr)
        return

    # 使用pandas读取数据
    df = pd.read_csv(filename)

    # 使用numpy计算统计量
    mean_val = np.mean(df['value'])
    std_val = np.std(df['value'])

    # 使用datetime处理时间
    now = datetime.now()
    yesterday = now - timedelta(days=1)

    # 使用matplotlib绘图
    plt.plot(df['date'], df['value'])
    plt.title(f'数据分析 - {now.strftime("%Y-%m-%d")}')
    plt.show()

    return {
        'mean': mean_val,
        'std': std_val,
        'analyzed_at': now
    }
```

这个例子展示了:
- `import sys` - 导入整个系统模块
- `from pathlib import Path` - 导入特定类
- `import pandas as pd` - 使用约定俗成的别名
- `from datetime import datetime, timedelta` - 导入多个相关类
- `import matplotlib.pyplot as plt` - 导入子模块并使用别名

每种导入方式都有其适用场景,选对了可以让代码更清晰、更易维护!

## 创建自己的模块

了解了如何使用别人的模块,现在让我们学习如何创建自己的模块。其实创建模块非常简单,**任何一个.py文件都可以作为模块被导入**!但是,要创建一个好用、易维护的模块,还是有很多技巧的。

### 创建模块的基本步骤 - 从零开始

让我们从最简单的模块开始,一步步学习如何创建专业的模块。

#### 步骤1: 创建一个.py文件

就这么简单!创建一个.py文件,写一些函数,它就是一个模块了:

```python
# greeting.py - 我的第一个模块

def say_hello(name):
    """打招呼"""
    return f"你好, {name}!"

def say_goodbye(name):
    """说再见"""
    return f"再见, {name}!"
```

#### 步骤2: 在另一个文件中使用这个模块

```python
# main.py
import greeting

print(greeting.say_hello("张三"))    # 你好, 张三!
print(greeting.say_goodbye("李四"))   # 再见, 李四!
```

就这么简单!你已经创建并使用了自己的第一个模块!

### 例子1: 简单的数学工具模块 - 从基础到完善

让我们创建一个数学工具模块,看看如何从简单的版本逐步完善:

#### 版本1: 最基本的版本

```python
# mymath.py
"""
我的数学工具模块 - 基础版本
"""

def add(a, b):
    return a + b

def subtract(a, b):
    return a - b

def multiply(a, b):
    return a * b

def divide(a, b):
    return a / b
```

这个版本能用,但还不够好。让我们改进它:

#### 版本2: 添加错误处理和文档

```python
# mymath.py
"""
我的数学工具模块 - 改进版本

这个模块提供了基本的数学运算功能,包括:
- add: 加法
- subtract: 减法
- multiply: 乘法
- divide: 除法(会检查除零错误)

作者: 你的名字
日期: 2024-01-15
"""

def add(a, b):
    """
    计算两个数的和

    参数:
        a: 第一个数
        b: 第二个数

    返回:
        两个数的和

    例子:
        >>> add(3, 5)
        8
        >>> add(-2, 8)
        6
    """
    return a + b

def subtract(a, b):
    """
    计算两个数的差

    参数:
        a: 被减数
        b: 减数

    返回:
        a - b的结果
    """
    return a - b

def multiply(a, b):
    """
    计算两个数的积

    参数:
        a: 第一个数
        b: 第二个数

    返回:
        两个数的积
    """
    return a * b

def divide(a, b):
    """
    计算两个数的商

    参数:
        a: 被除数
        b: 除数

    返回:
        a / b的结果

    异常:
        ValueError: 当除数为0时抛出

    例子:
        >>> divide(10, 2)
        5.0
        >>> divide(10, 0)
        Traceback (most recent call last):
        ...
        ValueError: 除数不能为0
    """
    if b == 0:
        raise ValueError("除数不能为0")
    return a / b

# 模块常量
PI = 3.14159265359
E = 2.71828182846

def circle_area(radius):
    """
    计算圆的面积

    参数:
        radius: 圆的半径

    返回:
        圆的面积
    """
    return PI * radius ** 2

def circle_circumference(radius):
    """
    计算圆的周长

    参数:
        radius: 圆的半径

    返回:
        圆的周长
    """
    return 2 * PI * radius
```

现在这个模块就专业多了!有详细的文档说明,有错误处理,还提供了一些实用的功能。

**使用这个模块:**

```python
# main.py
import mymath

# 基本运算
print(mymath.add(10, 5))       # 15
print(mymath.multiply(3, 4))   # 12

# 使用常量
print(f"圆周率: {mymath.PI}")   # 圆周率: 3.14159265359

# 计算圆的面积和周长
radius = 5
print(f"半径为{radius}的圆:")
print(f"面积: {mymath.circle_area(radius):.2f}")
print(f"周长: {mymath.circle_circumference(radius):.2f}")

# 错误处理
try:
    result = mymath.divide(10, 0)
except ValueError as e:
    print(f"发生错误: {e}")  # 发生错误: 除数不能为0
```

### 例子2: 学生管理模块 - 实际应用场景

让我们创建一个更实用的模块,用于管理学生信息:

```python
# student_manager.py
"""
学生管理模块

提供学生信息的增删改查功能,包括:
- 添加学生
- 删除学生
- 查找学生
- 更新学生信息
- 添加成绩
- 计算平均分
"""

# 模块级变量 - 存储所有学生
students = []

def add_student(name, age, student_id=None):
    """
    添加一个新学生

    参数:
        name: 学生姓名
        age: 学生年龄
        student_id: 学号(可选,如果不提供会自动生成)

    返回:
        新添加的学生字典
    """
    if student_id is None:
        # 自动生成学号
        student_id = f"S{len(students) + 1:04d}"  # S0001, S0002, ...

    # 检查学号是否已存在
    if find_student_by_id(student_id):
        print(f"错误: 学号 {student_id} 已存在")
        return None

    student = {
        "id": student_id,
        "name": name,
        "age": age,
        "scores": []
    }

    students.append(student)
    print(f"成功添加学生: {name} (学号: {student_id})")
    return student

def find_student_by_name(name):
    """
    根据姓名查找学生

    参数:
        name: 学生姓名

    返回:
        找到的学生字典,如果没找到返回None
    """
    for student in students:
        if student["name"] == name:
            return student
    return None

def find_student_by_id(student_id):
    """
    根据学号查找学生

    参数:
        student_id: 学号

    返回:
        找到的学生字典,如果没找到返回None
    """
    for student in students:
        if student["id"] == student_id:
            return student
    return None

def remove_student(student_id):
    """
    删除学生

    参数:
        student_id: 要删除的学生学号

    返回:
        True表示删除成功,False表示学生不存在
    """
    student = find_student_by_id(student_id)
    if student:
        students.remove(student)
        print(f"成功删除学生: {student['name']} ({student_id})")
        return True
    else:
        print(f"错误: 找不到学号为 {student_id} 的学生")
        return False

def add_score(student_id, subject, score):
    """
    为学生添加一门课程的成绩

    参数:
        student_id: 学号
        subject: 课程名称
        score: 分数

    返回:
        True表示添加成功,False表示学生不存在
    """
    student = find_student_by_id(student_id)
    if not student:
        print(f"错误: 找不到学号为 {student_id} 的学生")
        return False

    student["scores"].append({
        "subject": subject,
        "score": score
    })
    print(f"成功为 {student['name']} 添加 {subject} 成绩: {score}分")
    return True

def get_average_score(student_id):
    """
    计算学生的平均分

    参数:
        student_id: 学号

    返回:
        平均分,如果学生不存在或没有成绩返回None
    """
    student = find_student_by_id(student_id)
    if not student:
        print(f"错误: 找不到学号为 {student_id} 的学生")
        return None

    if not student["scores"]:
        return 0

    total = sum(item["score"] for item in student["scores"])
    avg = total / len(student["scores"])
    return avg

def print_student_info(student_id):
    """
    打印学生的详细信息

    参数:
        student_id: 学号
    """
    student = find_student_by_id(student_id)
    if not student:
        print(f"错误: 找不到学号为 {student_id} 的学生")
        return

    print(f"\n{'='*40}")
    print(f"学号: {student['id']}")
    print(f"姓名: {student['name']}")
    print(f"年龄: {student['age']}")

    if student["scores"]:
        print(f"\n成绩:")
        for item in student["scores"]:
            print(f"  {item['subject']}: {item['score']}分")
        avg = get_average_score(student_id)
        print(f"\n平均分: {avg:.2f}分")
    else:
        print("\n暂无成绩记录")

    print(f"{'='*40}\n")

def list_all_students():
    """
    列出所有学生的基本信息
    """
    if not students:
        print("目前没有学生记录")
        return

    print(f"\n共有 {len(students)} 名学生:")
    print(f"{'学号':<10} {'姓名':<10} {'年龄':<5} {'平均分':<10}")
    print("-" * 40)

    for student in students:
        avg = get_average_score(student["id"])
        avg_str = f"{avg:.2f}" if avg else "暂无成绩"
        print(f"{student['id']:<10} {student['name']:<10} {student['age']:<5} {avg_str:<10}")
    print()
```

**使用这个学生管理模块:**

```python
# main.py
import student_manager as sm

# 添加学生
sm.add_student("张三", 18)
sm.add_student("李四", 19)
sm.add_student("王五", 20)

# 添加成绩
sm.add_score("S0001", "数学", 85)
sm.add_score("S0001", "英语", 92)
sm.add_score("S0001", "物理", 78)

sm.add_score("S0002", "数学", 76)
sm.add_score("S0002", "英语", 88)

# 查看学生信息
sm.print_student_info("S0001")

# 列出所有学生
sm.list_all_students()

# 计算平均分
avg = sm.get_average_score("S0001")
print(f"张三的平均分: {avg:.2f}分")
```

输出:

```
成功添加学生: 张三 (学号: S0001)
成功添加学生: 李四 (学号: S0002)
成功添加学生: 王五 (学号: S0003)
成功为 张三 添加 数学 成绩: 85分
成功为 张三 添加 英语 成绩: 92分
成功为 张三 添加 物理 成绩: 78分
成功为 李四 添加 数学 成绩: 76分
成功为 李四 添加 英语 成绩: 88分

========================================
学号: S0001
姓名: 张三
年龄: 18

成绩:
  数学: 85分
  英语: 92分
  物理: 78分

平均分: 85.00分
========================================

共有 3 名学生:
学号         姓名         年龄    平均分
----------------------------------------
S0001      张三         18    85.00
S0002      李四         19    82.00
S0003      王五         20    暂无成绩

张三的平均分: 85.00分
```

### 例子3: 文件工具模块 - 实用工具集合

让我们再创建一个实用的文件操作工具模块:

```python
# file_utils.py
"""
文件操作工具模块

提供常用的文件操作功能:
- 安全地读取文件
- 安全地写入文件
- 追加内容到文件
- 获取文件信息
- 批量处理文件
"""

import os
from datetime import datetime

def safe_read(filename, encoding="utf-8", default=""):
    """
    安全地读取文件内容

    如果文件不存在或读取失败,返回默认值而不是抛出异常

    参数:
        filename: 文件名
        encoding: 文件编码,默认utf-8
        default: 文件不存在时返回的默认值

    返回:
        文件内容或默认值
    """
    try:
        with open(filename, "r", encoding=encoding) as f:
            return f.read()
    except FileNotFoundError:
        print(f"文件不存在: {filename}")
        return default
    except UnicodeDecodeError:
        print(f"文件编码错误,尝试使用gbk编码读取")
        try:
            with open(filename, "r", encoding="gbk") as f:
                return f.read()
        except:
            print(f"读取失败: {filename}")
            return default
    except Exception as e:
        print(f"读取文件时发生错误: {e}")
        return default

def safe_write(filename, content, encoding="utf-8"):
    """
    安全地写入文件

    参数:
        filename: 文件名
        content: 要写入的内容
        encoding: 文件编码,默认utf-8

    返回:
        True表示成功,False表示失败
    """
    try:
        with open(filename, "w", encoding=encoding) as f:
            f.write(content)
        print(f"成功写入文件: {filename}")
        return True
    except Exception as e:
        print(f"写入文件时发生错误: {e}")
        return False

def append_line(filename, line, encoding="utf-8"):
    """
    向文件追加一行

    参数:
        filename: 文件名
        line: 要追加的内容
        encoding: 文件编码,默认utf-8
    """
    try:
        with open(filename, "a", encoding=encoding) as f:
            # 如果line不以换行符结尾,自动添加
            if not line.endswith("\n"):
                line += "\n"
            f.write(line)
        return True
    except Exception as e:
        print(f"追加到文件时发生错误: {e}")
        return False

def get_file_info(filename):
    """
    获取文件的详细信息

    参数:
        filename: 文件名

    返回:
        包含文件信息的字典,如果文件不存在返回None
    """
    if not os.path.exists(filename):
        print(f"文件不存在: {filename}")
        return None

    stat = os.stat(filename)

    return {
        "name": os.path.basename(filename),
        "path": os.path.abspath(filename),
        "size": stat.st_size,
        "size_mb": stat.st_size / (1024 * 1024),
        "created": datetime.fromtimestamp(stat.st_ctime),
        "modified": datetime.fromtimestamp(stat.st_mtime),
        "is_file": os.path.isfile(filename),
        "is_dir": os.path.isdir(filename)
    }

def print_file_info(filename):
    """
    打印文件的详细信息

    参数:
        filename: 文件名
    """
    info = get_file_info(filename)
    if not info:
        return

    print(f"\n文件信息:")
    print(f"  文件名: {info['name']}")
    print(f"  完整路径: {info['path']}")
    print(f"  大小: {info['size']} 字节 ({info['size_mb']:.2f} MB)")
    print(f"  创建时间: {info['created'].strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"  修改时间: {info['modified'].strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"  类型: {'文件' if info['is_file'] else '目录'}\n")

def list_files_by_extension(directory=".", extension=".txt"):
    """
    列出目录中所有指定扩展名的文件

    参数:
        directory: 要搜索的目录,默认当前目录
        extension: 文件扩展名,默认.txt

    返回:
        文件名列表
    """
    try:
        files = []
        for filename in os.listdir(directory):
            filepath = os.path.join(directory, filename)
            if os.path.isfile(filepath) and filename.endswith(extension):
                files.append(filename)
        return files
    except Exception as e:
        print(f"列出文件时发生错误: {e}")
        return []

def backup_file(filename):
    """
    备份文件(在文件名后添加时间戳)

    参数:
        filename: 要备份的文件名

    返回:
        备份文件的文件名,失败返回None
    """
    if not os.path.exists(filename):
        print(f"文件不存在: {filename}")
        return None

    # 生成备份文件名: 原文件名_20240115_143025.ext
    name, ext = os.path.splitext(filename)
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    backup_name = f"{name}_{timestamp}{ext}"

    try:
        # 读取原文件
        content = safe_read(filename)
        # 写入备份文件
        safe_write(backup_name, content)
        print(f"成功备份到: {backup_name}")
        return backup_name
    except Exception as e:
        print(f"备份文件时发生错误: {e}")
        return None
```

**使用文件工具模块:**

```python
# test_file_utils.py
import file_utils as fu

# 测试写入文件
content = """这是测试内容
第二行
第三行"""
fu.safe_write("test.txt", content)

# 测试读取文件
read_content = fu.safe_read("test.txt")
print(f"读取的内容:\n{read_content}")

# 追加内容
fu.append_line("test.txt", "第四行")
fu.append_line("test.txt", "第五行")

# 查看文件信息
fu.print_file_info("test.txt")

# 备份文件
backup = fu.backup_file("test.txt")

# 列出当前目录所有.txt文件
txt_files = fu.list_files_by_extension(".", ".txt")
print(f"找到 {len(txt_files)} 个.txt文件:")
for f in txt_files:
    print(f"  - {f}")
```

### 模块设计的最佳实践

通过上面的例子,我们可以总结出一些创建优秀模块的最佳实践:

#### 1. 添加模块文档字符串

在文件开头写清楚模块的用途:

```python
"""
模块名称

这个模块的作用是什么
提供了哪些功能
如何使用它

作者: 你的名字
日期: 2024-01-15
版本: 1.0.0
"""
```

#### 2. 为每个函数添加文档字符串

```python
def function_name(param1, param2):
    """
    函数的简短描述

    更详细的说明(可选)

    参数:
        param1: 参数1的说明
        param2: 参数2的说明

    返回:
        返回值的说明

    异常:
        可能抛出的异常(如果有)

    例子:
        >>> function_name(value1, value2)
        expected_result
    """
    pass
```

#### 3. 使用有意义的函数名和变量名

```python
# ✅ 好的命名
def calculate_total_price(items, tax_rate):
    pass

# ❌ 不好的命名
def calc(x, y):
    pass
```

#### 4. 添加错误处理

```python
def divide(a, b):
    """除法运算"""
    if b == 0:
        raise ValueError("除数不能为0")
    return a / b
```

#### 5. 使用模块级常量

```python
# 在模块顶部定义常量
DEFAULT_ENCODING = "utf-8"
MAX_RETRY_TIMES = 3
API_VERSION = "1.0.0"

def some_function():
    # 使用常量
    encoding = DEFAULT_ENCODING
```

#### 6. 组织好代码结构

```python
"""模块文档字符串"""

# 1. 导入标准库
import os
import sys
import json

# 2. 导入第三方库
import requests
import pandas as pd

# 3. 导入自己的模块
from mypackage import utils

# 4. 模块级常量
DEFAULT_VALUE = 100

# 5. 模块级变量(如果需要)
_cache = {}

# 6. 私有函数(以_开头,不希望被外部使用)
def _private_helper():
    pass

# 7. 公开函数(模块的主要功能)
def public_function1():
    pass

def public_function2():
    pass

# 8. 类定义(如果有)
class MyClass:
    pass

# 9. 测试代码(稍后会讲)
if __name__ == "__main__":
    pass
```

这样组织的代码清晰、易读、易维护!

## __name__ == "__main__" - 重要的模块测试技巧

这是Python中一个非常重要但初学者容易困惑的概念。让我们深入理解它的含义和用法。

### __name__是什么?为什么需要它?

`__name__`是Python的一个内置变量,它的值取决于你如何运行Python文件:

1. **直接运行文件时**,`__name__`的值是`"__main__"`
2. **作为模块导入时**,`__name__`的值是模块的名字(文件名)

听起来有点抽象?让我们看一个实际例子:

```python
# test.py
print(f"__name__的值是: {__name__}")
```

**场景1: 直接运行**

```bash
python test.py
```

输出:

```
__name__的值是: __main__
```

**场景2: 作为模块导入**

```python
# main.py
import test
```

运行`python main.py`时,输出:

```
__name__的值是: test
```

看到区别了吗?同一个文件,不同的运行方式,`__name__`的值不同!

### 为什么需要这个特性?

想象这样一个场景:你写了一个模块,里面有一些测试代码:

```python
# calculator.py
def add(a, b):
    """加法"""
    return a + b

def multiply(a, b):
    """乘法"""
    return a * b

# 测试代码
print("测试加法:", add(3, 5))
print("测试乘法:", multiply(3, 5))
```

**问题来了!**当别人导入你的模块时:

```python
# someone_else.py
import calculator  # 导入时会立刻执行测试代码!
```

输出:

```
测试加法: 8
测试乘法: 15
```

这很尴尬!别人只是想用你的`add`函数,结果导入时就执行了你的测试代码,控制台被污染了。

### 解决方案: if __name__ == "__main__"

使用这个特性,我们可以让测试代码只在直接运行时执行:

```python
# calculator.py
def add(a, b):
    """加法"""
    return a + b

def multiply(a, b):
    """乘法"""
    return a * b

# 只在直接运行时执行测试
if __name__ == "__main__":
    print("测试加法:", add(3, 5))
    print("测试乘法:", multiply(3, 5))
```

现在:

1. **直接运行**: `python calculator.py`
   ```
   测试加法: 8
   测试乘法: 15
   ```

2. **作为模块导入**: `import calculator`
   - 不会输出任何内容!

完美!模块可以被正常导入使用,又可以独立测试。

### 深入理解: 原理是什么?

让我们一步步分析这个机制:

```python
# example.py
print("1. 文件开始执行")
print(f"2. __name__ = {__name__}")

def hello():
    print("Hello!")

print("3. 函数定义完成")

if __name__ == "__main__":
    print("4. 进入if __name__ == '__main__'块")
    hello()
else:
    print("4. 没有进入if __name__ == '__main__'块")

print("5. 文件执行结束")
```

**场景1: 直接运行 `python example.py`**

```
1. 文件开始执行
2. __name__ = __main__
3. 函数定义完成
4. 进入if __name__ == '__main__'块
Hello!
5. 文件执行结束
```

**场景2: 作为模块导入 `import example`**

```
1. 文件开始执行
2. __name__ = example
3. 函数定义完成
4. 没有进入if __name__ == '__main__'块
5. 文件执行结束
```

看到了吗?
- 两种情况下,函数定义都会执行(所以可以导入使用)
- 但是`if __name__ == "__main__"`块只在直接运行时执行

### 实战例子: 编写可测试的模块

让我们看一些实际的应用场景:

#### 例子1: 简单的测试

```python
# string_utils.py
"""字符串处理工具"""

def reverse_string(text):
    """反转字符串"""
    return text[::-1]

def count_vowels(text):
    """统计元音字母数量"""
    vowels = "aeiouAEIOU"
    return sum(1 for char in text if char in vowels)

def capitalize_words(text):
    """每个单词首字母大写"""
    return text.title()

# 测试代码
if __name__ == "__main__":
    print("=== 字符串工具测试 ===\n")

    # 测试reverse_string
    test_str = "Hello World"
    print(f"原字符串: {test_str}")
    print(f"反转后: {reverse_string(test_str)}")
    print()

    # 测试count_vowels
    test_str2 = "Python Programming"
    print(f"字符串: {test_str2}")
    print(f"元音字母数量: {count_vowels(test_str2)}")
    print()

    # 测试capitalize_words
    test_str3 = "hello python world"
    print(f"原字符串: {test_str3}")
    print(f"首字母大写: {capitalize_words(test_str3)}")
```

**作为脚本运行**,会执行所有测试:

```bash
python string_utils.py
```

输出:

```
=== 字符串工具测试 ===

原字符串: Hello World
反转后: dlroW olleH

字符串: Python Programming
元音字母数量: 4

原字符串: hello python world
首字母大写: Hello Python World
```

**作为模块导入**,不会执行测试:

```python
from string_utils import reverse_string, count_vowels

text = "Hello"
print(reverse_string(text))  # olleH
print(count_vowels(text))    # 2
```

#### 例子2: 命令行工具

`if __name__ == "__main__"`常用于创建命令行工具:

```python
# image_resizer.py
"""图片大小调整工具"""

from PIL import Image
import sys
import os

def resize_image(input_path, output_path, width, height):
    """
    调整图片大小

    参数:
        input_path: 输入图片路径
        output_path: 输出图片路径
        width: 新宽度
        height: 新高度
    """
    try:
        img = Image.open(input_path)
        resized = img.resize((width, height))
        resized.save(output_path)
        print(f"成功: {input_path} -> {output_path}")
        print(f"新尺寸: {width}x{height}")
        return True
    except Exception as e:
        print(f"错误: {e}")
        return False

# 作为命令行工具使用
if __name__ == "__main__":
    if len(sys.argv) != 5:
        print("用法: python image_resizer.py <输入文件> <输出文件> <宽度> <高度>")
        print("例如: python image_resizer.py photo.jpg small.jpg 800 600")
        sys.exit(1)

    input_file = sys.argv[1]
    output_file = sys.argv[2]
    new_width = int(sys.argv[3])
    new_height = int(sys.argv[4])

    if not os.path.exists(input_file):
        print(f"错误: 文件不存在: {input_file}")
        sys.exit(1)

    resize_image(input_file, output_file, new_width, new_height)
```

**作为命令行工具**:

```bash
python image_resizer.py photo.jpg small.jpg 800 600
```

**作为模块导入**:

```python
from image_resizer import resize_image

resize_image("photo.jpg", "thumbnail.jpg", 200, 200)
```

#### 例子3: 完整的模块结构

让我们看一个完整的、专业的模块例子:

```python
# data_processor.py
"""
数据处理模块

提供数据清洗、分析、导出等功能
"""

import json
from datetime import datetime

# 模块常量
VERSION = "1.0.0"
SUPPORTED_FORMATS = ["json", "csv", "txt"]

def clean_data(data):
    """
    清洗数据: 去除空值和重复项

    参数:
        data: 数据列表

    返回:
        清洗后的数据列表
    """
    # 去除None和空字符串
    cleaned = [item for item in data if item]
    # 去除重复
    cleaned = list(set(cleaned))
    return sorted(cleaned)

def analyze_data(data):
    """
    分析数据: 计算统计信息

    参数:
        data: 数值数据列表

    返回:
        包含统计信息的字典
    """
    if not data:
        return None

    return {
        "count": len(data),
        "sum": sum(data),
        "average": sum(data) / len(data),
        "max": max(data),
        "min": min(data)
    }

def export_data(data, filename, format="json"):
    """
    导出数据到文件

    参数:
        data: 要导出的数据
        filename: 文件名
        format: 格式(json/csv/txt)

    返回:
        True表示成功,False表示失败
    """
    if format not in SUPPORTED_FORMATS:
        print(f"不支持的格式: {format}")
        return False

    try:
        if format == "json":
            with open(filename, "w", encoding="utf-8") as f:
                json.dump(data, f, indent=2, ensure_ascii=False)
        elif format == "txt":
            with open(filename, "w", encoding="utf-8") as f:
                for item in data:
                    f.write(str(item) + "\n")

        print(f"数据已导出到: {filename}")
        return True
    except Exception as e:
        print(f"导出失败: {e}")
        return False

def _private_helper(data):
    """私有辅助函数(不希望被外部使用)"""
    pass

# 主函数 - 用于测试和演示
def main():
    """主函数 - 演示模块功能"""
    print(f"=== 数据处理模块 v{VERSION} ===\n")

    # 1. 测试数据清洗
    print("1. 测试数据清洗")
    raw_data = [1, 2, 2, 3, None, "", 4, 3, 5]
    print(f"   原始数据: {raw_data}")
    cleaned = clean_data(raw_data)
    print(f"   清洗后: {cleaned}\n")

    # 2. 测试数据分析
    print("2. 测试数据分析")
    numbers = [10, 20, 30, 40, 50]
    print(f"   数据: {numbers}")
    stats = analyze_data(numbers)
    print(f"   统计信息:")
    for key, value in stats.items():
        print(f"     {key}: {value}")
    print()

    # 3. 测试数据导出
    print("3. 测试数据导出")
    test_data = {"name": "测试", "values": [1, 2, 3]}
    export_data(test_data, "test_output.json", "json")
    print()

    print("=== 测试完成 ===")

# 只在直接运行时执行主函数
if __name__ == "__main__":
    main()
```

这个模块:
- ✅ 有完整的文档
- ✅ 提供了实用的功能
- ✅ 可以被导入使用
- ✅ 可以独立运行测试
- ✅ 有版本号和常量
- ✅ 有私有函数
- ✅ 有主函数用于演示

**作为模块使用**:

```python
import data_processor as dp

data = [1, 2, 2, 3, 4, 5]
cleaned = dp.clean_data(data)
stats = dp.analyze_data(cleaned)
dp.export_data(stats, "result.json")
```

**作为脚本运行**:

```bash
python data_processor.py
```

会执行`main()`函数,显示所有测试结果。

### 总结: if __name__ == "__main__"的作用

1. **模块功能**: 让文件既可以作为模块被导入,又可以作为脚本独立运行
2. **测试代码**: 在模块中包含测试代码,不影响其他人导入使用
3. **命令行工具**: 创建可以在命令行使用的工具脚本
4. **演示功能**: 提供模块功能的使用示例

**编写模块的标准模式**:

```python
"""模块文档字符串"""

# 导入
import xxx

# 常量
CONSTANT = xxx

# 函数定义
def function1():
    pass

def function2():
    pass

# 主函数(可选)
def main():
    """演示和测试"""
    pass

# 只在直接运行时执行
if __name__ == "__main__":
    main()
```

(继续编写...)
